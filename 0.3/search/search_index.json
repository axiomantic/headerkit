{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"clangir","text":"<p>A C/C++ header parsing toolkit with pluggable backends and writers.</p> <p>clangir parses C and C++ header files into a language-agnostic Intermediate Representation (IR), then transforms that IR into various output formats. Use it to generate FFI bindings, serialize header metadata to JSON, or build your own custom code generators.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Pluggable parser backends -- swap between parsing implementations (libclang ships built-in) without changing your code</li> <li>Dataclass-based IR -- a clean, inspectable Python representation of C/C++ declarations: structs, functions, enums, typedefs, and more</li> <li>Pluggable output writers -- generate CFFI bindings, JSON, or write your own writer for any target format</li> <li>Registry pattern -- backends and writers self-register, making the system extensible without modifying core code</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from clangir import get_backend, get_writer\n\n# Parse a C header\nbackend = get_backend()\nheader = backend.parse(\n    open(\"mylib.h\").read(),\n    \"mylib.h\",\n)\n\n# Generate CFFI bindings\nwriter = get_writer(\"cffi\")\ncdef_source = writer.write(header)\n\n# Or serialize to JSON for inspection\njson_writer = get_writer(\"json\", indent=2)\nprint(json_writer.write(header))\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>C/C++ Header --&gt; [Backend] --&gt; IR --&gt; [Writer] --&gt; Output\n                    ^                    ^\n                    |                    |\n              ParserBackend        WriterBackend\n                Protocol             Protocol\n</code></pre> <ol> <li>A backend (e.g., <code>LibclangBackend</code>) parses C/C++ source code and produces an IR <code>Header</code> object containing <code>Declaration</code> nodes.</li> <li>A writer (e.g., <code>CffiWriter</code>, <code>JsonWriter</code>) consumes the IR and produces output in a target format.</li> </ol> <p>Both backends and writers follow simple protocols and are registered in a global registry, so you can add your own without modifying clangir itself.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p>Installation</p> <p>Install clangir and its system dependency (libclang).</p> <p>:octicons-arrow-right-24: Installation</p> </li> <li> <p>Quick Start</p> <p>Parse your first header and generate bindings in under five minutes.</p> <p>:octicons-arrow-right-24: Quick Start</p> </li> <li> <p>Architecture</p> <p>Understand the three-layer backend/IR/writer architecture.</p> <p>:octicons-arrow-right-24: Architecture Overview</p> </li> <li> <p>API Reference</p> <p>Full reference for all IR types, backends, and writers.</p> <p>:octicons-arrow-right-24: API Reference</p> </li> </ul>"},{"location":"guides/architecture/","title":"Architecture Overview","text":"<p>clangir is organized around a three-layer pipeline: backends parse C/C++ headers, producing an IR (Intermediate Representation), which writers consume to generate output.</p>"},{"location":"guides/architecture/#the-pipeline","title":"The Pipeline","text":"<pre><code>C/C++ Source Code\n       |\n       v\n  +-----------+\n  |  Backend  |   ParserBackend protocol\n  +-----------+   e.g., LibclangBackend\n       |\n       v\n  +-----------+\n  |    IR     |   Header, Declaration, TypeExpr dataclasses\n  +-----------+\n       |\n       v\n  +-----------+\n  |  Writer   |   WriterBackend protocol\n  +-----------+   e.g., CffiWriter, JsonWriter\n       |\n       v\n  Output String\n  (CFFI cdef, JSON, ...)\n</code></pre> <p>Each layer is independent. Backends know nothing about writers. Writers know nothing about backends. The IR is the contract between them.</p>"},{"location":"guides/architecture/#layer-1-backends-parsing","title":"Layer 1: Backends (Parsing)","text":"<p>A backend implements the <code>ParserBackend</code> protocol and converts C/C++ source code into IR.</p> <pre><code>from clangir import ParserBackend\nfrom clangir.ir import Header\n\nclass ParserBackend(Protocol):\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n        *,\n        use_default_includes: bool = True,\n        recursive_includes: bool = True,\n        max_depth: int = 10,\n        project_prefixes: tuple[str, ...] | None = None,\n    ) -&gt; Header: ...\n\n    @property\n    def name(self) -&gt; str: ...\n\n    @property\n    def supports_macros(self) -&gt; bool: ...\n\n    @property\n    def supports_cpp(self) -&gt; bool: ...\n</code></pre>"},{"location":"guides/architecture/#built-in-backend-libclangbackend","title":"Built-in Backend: LibclangBackend","text":"<p>The <code>LibclangBackend</code> uses LLVM's libclang to parse headers. It provides:</p> <ul> <li>Full C and C++ support (templates, namespaces, classes)</li> <li>Preprocessor handling (<code>#include</code>, <code>#define</code>, <code>#ifdef</code>)</li> <li>Source location tracking for error reporting</li> <li>Recursive include processing for umbrella headers</li> </ul> <pre><code>from clangir import get_backend\n\nbackend = get_backend(\"libclang\")\nheader = backend.parse(code, \"myheader.h\")\n</code></pre>"},{"location":"guides/architecture/#backend-registry","title":"Backend Registry","text":"<p>Backends register themselves using <code>register_backend()</code>:</p> <pre><code>from clangir.backends import register_backend\n\nregister_backend(\"mybackend\", MyBackendClass, is_default=False)\n</code></pre> <p>Registry functions:</p> Function Description <code>get_backend(name=None)</code> Get a backend instance (default if <code>name</code> is <code>None</code>) <code>list_backends()</code> List all registered backend names <code>is_backend_available(name)</code> Check if a backend is registered <code>register_backend(name, cls)</code> Register a new backend <p>See Writing Custom Backends for a complete guide.</p>"},{"location":"guides/architecture/#layer-2-ir-intermediate-representation","title":"Layer 2: IR (Intermediate Representation)","text":"<p>The IR is a tree of Python dataclasses rooted at <code>Header</code>. It is designed to be parser-agnostic: any backend that can parse C/C++ can produce the same IR.</p>"},{"location":"guides/architecture/#type-expressions","title":"Type Expressions","text":"<p>Type expressions (<code>TypeExpr</code>) represent C types as composable trees:</p> Class Represents Example <code>CType</code> Base type with qualifiers <code>int</code>, <code>const char</code>, <code>unsigned long</code> <code>Pointer</code> Pointer to another type <code>int*</code>, <code>const char*</code>, <code>void**</code> <code>Array</code> Fixed or flexible array <code>int[10]</code>, <code>char[]</code> <code>FunctionPointer</code> Function pointer <code>void (*)(int, char*)</code> <p>Types compose naturally:</p> <pre><code>from clangir import CType, Pointer, Array\n\n# const char*\nconst_char_ptr = Pointer(CType(\"char\", [\"const\"]))\n\n# int**\nint_ptr_ptr = Pointer(Pointer(CType(\"int\")))\n\n# const char*[]\nstring_array = Array(Pointer(CType(\"char\", [\"const\"])))\n</code></pre>"},{"location":"guides/architecture/#declarations","title":"Declarations","text":"<p>Declarations (<code>Declaration</code>) represent top-level C/C++ constructs:</p> Class Represents <code>Struct</code> Structs, unions, and C++ classes <code>Enum</code> Enumerations with named constants <code>Function</code> Function prototypes <code>Typedef</code> Type aliases <code>Variable</code> Global/extern variables <code>Constant</code> <code>#define</code> macros and <code>const</code> values"},{"location":"guides/architecture/#the-header-container","title":"The Header Container","text":"<p><code>Header</code> is the top-level container returned by all backends:</p> <pre><code>from clangir.ir import Header\n\n# Header fields:\n#   path: str                        -- original file path\n#   declarations: list[Declaration]  -- all extracted declarations\n#   included_headers: set[str]       -- basenames of included headers\n</code></pre>"},{"location":"guides/architecture/#layer-3-writers-output","title":"Layer 3: Writers (Output)","text":"<p>A writer implements the <code>WriterBackend</code> protocol and converts IR into a string output:</p> <pre><code>from clangir.writers import WriterBackend\nfrom clangir.ir import Header\n\nclass WriterBackend(Protocol):\n    def write(self, header: Header) -&gt; str: ...\n\n    @property\n    def name(self) -&gt; str: ...\n\n    @property\n    def format_description(self) -&gt; str: ...\n</code></pre> <p>Writer-specific options (e.g., <code>exclude_patterns</code> for CFFI, <code>indent</code> for JSON) are constructor parameters on the concrete class, not part of the <code>write()</code> method signature.</p>"},{"location":"guides/architecture/#built-in-writers","title":"Built-in Writers","text":"Writer Output Constructor Options <code>CffiWriter</code> CFFI <code>cdef</code> strings <code>exclude_patterns: list[str] \\| None</code> <code>JsonWriter</code> JSON serialization <code>indent: int \\| None</code>"},{"location":"guides/architecture/#writer-registry","title":"Writer Registry","text":"<p>Writers use the same registry pattern as backends:</p> <pre><code>from clangir.writers import register_writer\n\nregister_writer(\"mywriter\", MyWriterClass, description=\"My custom output format\")\n</code></pre> <p>Registry functions:</p> Function Description <code>get_writer(name=None, **kwargs)</code> Get a writer instance; kwargs forwarded to constructor <code>list_writers()</code> List all registered writer names <code>is_writer_available(name)</code> Check if a writer is registered <code>register_writer(name, cls)</code> Register a new writer <code>get_writer_info()</code> Get metadata for all writers <p>See Writing Custom Writers for a complete guide.</p>"},{"location":"guides/architecture/#design-principles","title":"Design Principles","text":"<p>Parser-agnostic IR. The IR does not leak backend-specific details. A <code>Struct</code> from libclang looks exactly the same as a <code>Struct</code> from any other backend. This means writers work identically regardless of which backend produced the IR.</p> <p>Composable types. Type expressions are recursive dataclasses that mirror how C types actually compose. <code>const char**</code> is <code>Pointer(Pointer(CType(\"char\", [\"const\"])))</code> -- no string parsing needed.</p> <p>Best-effort output. Writers silently skip declarations they cannot represent rather than raising exceptions. This makes the pipeline robust against headers with exotic constructs.</p> <p>Self-registering plugins. Both backends and writers register themselves at import time. Adding a new backend or writer requires zero changes to clangir's core code. Just implement the protocol, call <code>register_backend()</code> or <code>register_writer()</code>, and your plugin is available through <code>get_backend()</code> or <code>get_writer()</code>.</p>"},{"location":"guides/cffi/","title":"Using the CFFI Writer","text":"<p>The CFFI writer converts clangir IR into C declaration strings compatible with CFFI's <code>ffibuilder.cdef()</code>. This is the most common workflow: parse a C header, generate cdef declarations, and use them to build Python bindings for a C library.</p>"},{"location":"guides/cffi/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/cffi/#using-get_writer","title":"Using get_writer()","text":"<pre><code>from clangir import get_backend, get_writer\n\nbackend = get_backend()\nheader = backend.parse(open(\"mylib.h\").read(), \"mylib.h\")\n\nwriter = get_writer(\"cffi\")\ncdef_source = writer.write(header)\nprint(cdef_source)\n</code></pre>"},{"location":"guides/cffi/#using-header_to_cffi-directly","title":"Using header_to_cffi() Directly","text":"<p>The <code>header_to_cffi()</code> function provides the same functionality without going through the writer registry:</p> <pre><code>from clangir import get_backend\nfrom clangir.writers.cffi import header_to_cffi\n\nbackend = get_backend()\nheader = backend.parse(open(\"mylib.h\").read(), \"mylib.h\")\n\ncdef_source = header_to_cffi(header)\n</code></pre>"},{"location":"guides/cffi/#complete-cffi-example","title":"Complete CFFI Example","text":"<p>Here is a full example that parses a header, generates CFFI bindings, and compiles them into a usable Python module.</p> <p>Given a C header <code>calculator.h</code>:</p> <pre><code>typedef enum {\n    OP_ADD,\n    OP_SUB,\n    OP_MUL,\n    OP_DIV,\n} Operation;\n\ntypedef struct {\n    double result;\n    int error;\n} CalcResult;\n\nCalcResult calculate(double a, double b, Operation op);\nconst char *calc_error_string(int error_code);\n</code></pre> <p>Generate and use the bindings:</p> <pre><code>from cffi import FFI\nfrom clangir import get_backend, get_writer\n\n# Step 1: Parse the header\nbackend = get_backend()\nwith open(\"calculator.h\") as f:\n    code = f.read()\nheader = backend.parse(code, \"calculator.h\")\n\n# Step 2: Generate CFFI cdef\nwriter = get_writer(\"cffi\")\ncdef_source = writer.write(header)\n\n# Step 3: Set up CFFI\nffibuilder = FFI()\nffibuilder.cdef(cdef_source)\nffibuilder.set_source(\n    \"_calculator\",\n    '#include \"calculator.h\"',\n    sources=[\"calculator.c\"],\n)\n\n# Step 4: Compile\nffibuilder.compile(verbose=True)\n</code></pre> <p>After compilation, you can import and use the module:</p> <pre><code>from _calculator import ffi, lib\n\nresult = lib.calculate(10.0, 3.0, lib.OP_ADD)\nprint(f\"Result: {result.result}, Error: {result.error}\")\n</code></pre>"},{"location":"guides/cffi/#excluding-declarations","title":"Excluding Declarations","text":"<p>The CFFI writer supports <code>exclude_patterns</code> to filter out declarations by name. Patterns are Python regular expressions matched against declaration names.</p> <pre><code>writer = get_writer(\"cffi\", exclude_patterns=[\n    \"__.*\",           # Skip compiler builtins (__builtin_*, __attribute__, etc.)\n    \"_private_.*\",    # Skip private API functions\n    \"internal_.*\",    # Skip internal functions\n])\ncdef_source = writer.write(header)\n</code></pre> <p>You can also pass patterns directly to <code>header_to_cffi()</code>:</p> <pre><code>from clangir.writers.cffi import header_to_cffi\n\ncdef_source = header_to_cffi(header, exclude_patterns=[\"__.*\", \"test_.*\"])\n</code></pre> <p>Pattern matching</p> <p>Patterns use <code>re.search()</code>, so they match anywhere in the name. Use <code>^</code> and <code>$</code> anchors for exact matching: <code>\"^_private$\"</code> matches only the name <code>_private</code>, while <code>\"_private\"</code> matches anything containing <code>_private</code>.</p>"},{"location":"guides/cffi/#how-the-writer-handles-c-constructs","title":"How the Writer Handles C Constructs","text":""},{"location":"guides/cffi/#structs-and-unions","title":"Structs and Unions","text":"<p>Structs with fields are emitted with all their members. Opaque structs (no fields) are emitted as forward declarations:</p> <pre><code>/* With fields */\nstruct Point {\n    double x;\n    double y;\n};\n\n/* Opaque */\nstruct OpaqueHandle { ...; };\n</code></pre>"},{"location":"guides/cffi/#typedefs","title":"Typedefs","text":"<p>Typedefs are preserved, including function pointer typedefs:</p> <pre><code>typedef unsigned long size_t;\ntypedef void (*Callback)(int status, void *data);\n</code></pre>"},{"location":"guides/cffi/#enums","title":"Enums","text":"<p>Enum values are emitted with their explicit values when available:</p> <pre><code>typedef enum {\n    RED = 0,\n    GREEN = 1,\n    BLUE = 2,\n} Color;\n</code></pre>"},{"location":"guides/cffi/#constants","title":"Constants","text":"<p>Only integer <code>#define</code> constants are emitted, since CFFI's cdef parser only supports integer constant macros:</p> <pre><code>#define BUFFER_SIZE 1024\n</code></pre> <p>Non-integer macros</p> <p>String macros, expression macros, and macros with unknown values are silently skipped. If you need access to these, use the JSON writer to inspect the full IR.</p>"},{"location":"guides/cffi/#variadic-functions","title":"Variadic Functions","text":"<p>Variadic functions are fully supported:</p> <pre><code>int printf(const char *fmt, ...);\n</code></pre>"},{"location":"guides/custom-backends/","title":"Writing Custom Backends","text":"<p>clangir's backend system is pluggable. You can write your own parser backend to support alternative parsing strategies (tree-sitter, pycparser, hand-written parsers) and register it alongside the built-in <code>LibclangBackend</code>.</p>"},{"location":"guides/custom-backends/#the-parserbackend-protocol","title":"The ParserBackend Protocol","text":"<p>Every backend must implement the <code>ParserBackend</code> protocol:</p> <pre><code>from clangir.ir import Header, ParserBackend\n\nclass ParserBackend(Protocol):\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n        *,\n        use_default_includes: bool = True,\n        recursive_includes: bool = True,\n        max_depth: int = 10,\n        project_prefixes: tuple[str, ...] | None = None,\n    ) -&gt; Header: ...\n\n    @property\n    def name(self) -&gt; str: ...\n\n    @property\n    def supports_macros(self) -&gt; bool: ...\n\n    @property\n    def supports_cpp(self) -&gt; bool: ...\n</code></pre>"},{"location":"guides/custom-backends/#method-and-property-details","title":"Method and Property Details","text":"<p><code>parse(code, filename, ...)</code> -- Parse C/C++ source code and return a <code>Header</code> containing all extracted declarations. The <code>code</code> parameter is the source text (not a file path). The <code>filename</code> is used for error messages and <code>#line</code> directives; it does not need to exist on disk.</p> <p><code>name</code> -- A human-readable name for the backend (e.g., <code>\"tree-sitter\"</code>). This is the string users pass to <code>get_backend()</code>.</p> <p><code>supports_macros</code> -- Whether this backend can extract <code>#define</code> constants as <code>Constant</code> declarations.</p> <p><code>supports_cpp</code> -- Whether this backend can parse C++ code (classes, templates, namespaces).</p>"},{"location":"guides/custom-backends/#registering-a-backend","title":"Registering a Backend","text":"<p>Use <code>register_backend()</code> to add your backend to the global registry:</p> <pre><code>from clangir.backends import register_backend\n\nregister_backend(\"mybackend\", MyBackend, is_default=False)\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> -- The lookup key for <code>get_backend(name)</code></li> <li><code>backend_class</code> -- The class implementing <code>ParserBackend</code></li> <li><code>is_default</code> -- If <code>True</code>, this becomes the default backend returned by <code>get_backend()</code> with no arguments</li> </ul> <p>Registration timing</p> <p>Registration must happen at import time (module level), not inside a function. The registry is populated lazily when <code>get_backend()</code> or <code>list_backends()</code> is first called.</p>"},{"location":"guides/custom-backends/#example-tree-sitter-backend-skeleton","title":"Example: Tree-sitter Backend Skeleton","text":"<p>Here is a skeleton for a backend that uses tree-sitter to parse C headers:</p> <pre><code>\"\"\"Tree-sitter based parser backend for clangir.\"\"\"\n\nfrom __future__ import annotations\n\nfrom clangir.backends import register_backend\nfrom clangir.ir import (\n    CType,\n    Enum,\n    EnumValue,\n    Field,\n    Function,\n    Header,\n    Parameter,\n    Pointer,\n    SourceLocation,\n    Struct,\n    Typedef,\n)\n\n\nclass TreeSitterBackend:\n    \"\"\"Parser backend using tree-sitter-c.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return \"tree-sitter\"\n\n    @property\n    def supports_macros(self) -&gt; bool:\n        return False  # Would need separate macro handling\n\n    @property\n    def supports_cpp(self) -&gt; bool:\n        return False  # tree-sitter-c handles C only\n\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n        *,\n        use_default_includes: bool = True,\n        recursive_includes: bool = True,\n        max_depth: int = 10,\n        project_prefixes: tuple[str, ...] | None = None,\n    ) -&gt; Header:\n        import tree_sitter_c as tsc\n        from tree_sitter import Language, Parser\n\n        parser = Parser(Language(tsc.language()))\n        tree = parser.parse(code.encode())\n\n        declarations = []\n        for node in tree.root_node.children:\n            decl = self._convert_node(node, filename)\n            if decl is not None:\n                declarations.append(decl)\n\n        return Header(path=filename, declarations=declarations)\n\n    def _convert_node(self, node, filename):\n        \"\"\"Convert a tree-sitter node to an IR declaration.\n\n        This is where the bulk of the work goes: mapping tree-sitter's\n        concrete syntax tree nodes to clangir IR types.\n        \"\"\"\n        # Implementation would handle:\n        #   - \"struct_specifier\" -&gt; Struct\n        #   - \"enum_specifier\" -&gt; Enum\n        #   - \"function_definition\" / \"declaration\" -&gt; Function\n        #   - \"type_definition\" -&gt; Typedef\n        # Each node type needs its own conversion logic.\n        return None\n\n\n# Self-register at import time\ntry:\n    import tree_sitter_c  # noqa: F401\n\n    register_backend(\"tree-sitter\", TreeSitterBackend)\nexcept ImportError:\n    pass  # tree-sitter-c not installed; backend not available\n</code></pre>"},{"location":"guides/custom-backends/#using-your-backend","title":"Using Your Backend","text":"<p>Once registered, your backend is available through the standard API:</p> <pre><code>from clangir import get_backend, list_backends\n\n# List all available backends\nprint(list_backends())  # ['libclang', 'tree-sitter']\n\n# Use your backend explicitly\nbackend = get_backend(\"tree-sitter\")\nheader = backend.parse(code, \"example.h\")\n</code></pre>"},{"location":"guides/custom-backends/#producing-correct-ir","title":"Producing Correct IR","text":"<p>When implementing a backend, pay attention to these IR conventions:</p>"},{"location":"guides/custom-backends/#typedefs-vs-tagged-types","title":"Typedefs vs. Tagged Types","text":"<p>When C code uses <code>typedef struct { ... } Name;</code>, the IR should produce a <code>Struct</code> with <code>is_typedef=True</code>. This tells writers to emit the typedef form rather than a bare struct declaration.</p>"},{"location":"guides/custom-backends/#anonymous-types","title":"Anonymous Types","text":"<p>Set <code>name=None</code> for truly anonymous structs, enums, or unions. The built-in writers will skip anonymous types that cannot be referenced.</p>"},{"location":"guides/custom-backends/#source-locations","title":"Source Locations","text":"<p>Populate <code>SourceLocation</code> on declarations when possible. This enables filtering by file (to exclude system headers) and better error messages:</p> <pre><code>loc = SourceLocation(file=filename, line=node.start_point[0] + 1)\n</code></pre>"},{"location":"guides/custom-backends/#type-composition","title":"Type Composition","text":"<p>Build types from the inside out. For <code>const char **</code>:</p> <pre><code>from clangir import CType, Pointer\n\nconst_char = CType(\"char\", [\"const\"])\nconst_char_ptr = Pointer(const_char)\nconst_char_ptr_ptr = Pointer(const_char_ptr)\n</code></pre>"},{"location":"guides/custom-backends/#testing-your-backend","title":"Testing Your Backend","text":"<p>Test your backend by comparing its output against the built-in <code>LibclangBackend</code> for the same input:</p> <pre><code>from clangir import get_backend\n\ncode = \"\"\"\nstruct Point {\n    int x;\n    int y;\n};\n\nint add(int a, int b);\n\"\"\"\n\nlibclang = get_backend(\"libclang\")\ncustom = get_backend(\"my-backend\")\n\nexpected = libclang.parse(code, \"test.h\")\nactual = custom.parse(code, \"test.h\")\n\n# Compare declaration counts and types\nassert len(actual.declarations) == len(expected.declarations)\nfor exp, act in zip(expected.declarations, actual.declarations):\n    assert type(exp) == type(act)\n    assert exp.name == act.name\n</code></pre>"},{"location":"guides/custom-writers/","title":"Writing Custom Writers","text":"<p>clangir writers convert IR into output strings. You can create custom writers for any target format: Cython <code>.pxd</code> files, ctypes bindings, documentation, or anything else you need.</p>"},{"location":"guides/custom-writers/#the-writerbackend-protocol","title":"The WriterBackend Protocol","text":"<p>Every writer must implement the <code>WriterBackend</code> protocol:</p> <pre><code>from clangir.ir import Header\nfrom clangir.writers import WriterBackend\n\nclass WriterBackend(Protocol):\n    def write(self, header: Header) -&gt; str: ...\n\n    @property\n    def name(self) -&gt; str: ...\n\n    @property\n    def format_description(self) -&gt; str: ...\n</code></pre>"},{"location":"guides/custom-writers/#method-and-property-details","title":"Method and Property Details","text":"<p><code>write(header)</code> -- Convert a <code>Header</code> IR object into the target format string. Writers should produce best-effort output, silently skipping declarations they cannot represent. Writers must not raise exceptions for valid <code>Header</code> input.</p> <p><code>name</code> -- A human-readable name for the writer (e.g., <code>\"markdown\"</code>). This is the string users pass to <code>get_writer()</code>.</p> <p><code>format_description</code> -- A short description of the output format (e.g., <code>\"Markdown API documentation\"</code>). Used by <code>get_writer_info()</code>.</p>"},{"location":"guides/custom-writers/#writer-specific-options","title":"Writer-Specific Options","text":"<p>Configuration options belong on the writer's <code>__init__()</code>, not on <code>write()</code>. This keeps the protocol simple and type-safe:</p> <pre><code>class MarkdownWriter:\n    def __init__(self, include_source_locations: bool = False) -&gt; None:\n        self._include_locations = include_source_locations\n\n    def write(self, header: Header) -&gt; str:\n        # Use self._include_locations here\n        ...\n</code></pre> <p>Users pass options through <code>get_writer()</code>:</p> <pre><code>writer = get_writer(\"markdown\", include_source_locations=True)\n</code></pre>"},{"location":"guides/custom-writers/#registering-a-writer","title":"Registering a Writer","text":"<p>Use <code>register_writer()</code> to add your writer to the global registry:</p> <pre><code>from clangir.writers import register_writer\n\nregister_writer(\n    \"markdown\",\n    MarkdownWriter,\n    description=\"Markdown API documentation\",\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>name</code> -- The lookup key for <code>get_writer(name)</code></li> <li><code>writer_class</code> -- The class implementing <code>WriterBackend</code></li> <li><code>is_default</code> -- If <code>True</code>, this becomes the default writer</li> <li><code>description</code> -- Short description; falls back to the class docstring's first line if not provided</li> </ul> <p>Unique names</p> <p><code>register_writer()</code> raises <code>ValueError</code> if a writer with the same name is already registered. Choose a unique name for your writer.</p>"},{"location":"guides/custom-writers/#complete-example-markdown-documentation-writer","title":"Complete Example: Markdown Documentation Writer","text":"<p>Here is a complete writer that generates Markdown documentation from a parsed C header:</p> <pre><code>\"\"\"Generate Markdown API documentation from clangir IR.\"\"\"\n\nfrom __future__ import annotations\n\nfrom clangir.ir import (\n    Constant,\n    Declaration,\n    Enum,\n    Function,\n    Header,\n    Struct,\n    Typedef,\n    Variable,\n)\nfrom clangir.writers import register_writer\n\n\nclass MarkdownWriter:\n    \"\"\"Writer that generates Markdown API documentation.\"\"\"\n\n    def __init__(self, include_source_locations: bool = False) -&gt; None:\n        self._include_locations = include_source_locations\n\n    def write(self, header: Header) -&gt; str:\n        lines = [f\"# API Reference: `{header.path}`\", \"\"]\n\n        # Group declarations by kind\n        structs = [d for d in header.declarations if isinstance(d, Struct)]\n        enums = [d for d in header.declarations if isinstance(d, Enum)]\n        functions = [d for d in header.declarations if isinstance(d, Function)]\n        typedefs = [d for d in header.declarations if isinstance(d, Typedef)]\n        constants = [d for d in header.declarations if isinstance(d, Constant)]\n\n        if structs:\n            lines.append(\"## Structures\")\n            lines.append(\"\")\n            for s in structs:\n                lines.extend(self._format_struct(s))\n\n        if enums:\n            lines.append(\"## Enumerations\")\n            lines.append(\"\")\n            for e in enums:\n                lines.extend(self._format_enum(e))\n\n        if functions:\n            lines.append(\"## Functions\")\n            lines.append(\"\")\n            for f in functions:\n                lines.extend(self._format_function(f))\n\n        if typedefs:\n            lines.append(\"## Type Aliases\")\n            lines.append(\"\")\n            for t in typedefs:\n                lines.append(f\"- `{t.name}` -- alias for `{t.underlying_type}`\")\n            lines.append(\"\")\n\n        if constants:\n            lines.append(\"## Constants\")\n            lines.append(\"\")\n            for c in constants:\n                if c.value is not None:\n                    lines.append(f\"- `{c.name}` = `{c.value}`\")\n                else:\n                    lines.append(f\"- `{c.name}`\")\n            lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    def _format_struct(self, s: Struct) -&gt; list[str]:\n        kind = \"Union\" if s.is_union else \"Struct\"\n        lines = [f\"### `{s.name}` ({kind})\", \"\"]\n        if s.fields:\n            lines.append(\"| Field | Type |\")\n            lines.append(\"|-------|------|\")\n            for field in s.fields:\n                lines.append(f\"| `{field.name}` | `{field.type}` |\")\n        else:\n            lines.append(\"*Opaque type*\")\n        lines.append(\"\")\n        return lines\n\n    def _format_enum(self, e: Enum) -&gt; list[str]:\n        name = e.name or \"(anonymous)\"\n        lines = [f\"### `{name}`\", \"\"]\n        if e.values:\n            lines.append(\"| Constant | Value |\")\n            lines.append(\"|----------|-------|\")\n            for v in e.values:\n                val = str(v.value) if v.value is not None else \"(auto)\"\n                lines.append(f\"| `{v.name}` | {val} |\")\n        lines.append(\"\")\n        return lines\n\n    def _format_function(self, f: Function) -&gt; list[str]:\n        params = \", \".join(\n            f\"{p.type} {p.name}\" if p.name else str(p.type)\n            for p in f.parameters\n        )\n        if f.is_variadic:\n            params = f\"{params}, ...\" if params else \"...\"\n        lines = [\n            f\"### `{f.name}`\",\n            \"\",\n            f\"```c\",\n            f\"{f.return_type} {f.name}({params});\",\n            f\"```\",\n            \"\",\n        ]\n        if self._include_locations and f.location:\n            lines.append(\n                f\"*Defined at {f.location.file}:{f.location.line}*\"\n            )\n            lines.append(\"\")\n        return lines\n\n    @property\n    def name(self) -&gt; str:\n        return \"markdown\"\n\n    @property\n    def format_description(self) -&gt; str:\n        return \"Markdown API documentation\"\n\n\n# Self-register\nregister_writer(\"markdown\", MarkdownWriter, description=\"Markdown API documentation\")\n</code></pre>"},{"location":"guides/custom-writers/#using-your-writer","title":"Using Your Writer","text":"<p>Once registered, your writer is available through the standard API:</p> <pre><code>from clangir import get_backend, get_writer, list_writers\n\n# List all available writers\nprint(list_writers())  # ['cffi', 'json', 'markdown']\n\n# Use your writer\nbackend = get_backend()\nheader = backend.parse(code, \"mylib.h\")\n\nwriter = get_writer(\"markdown\", include_source_locations=True)\ndocs = writer.write(header)\nprint(docs)\n</code></pre>"},{"location":"guides/custom-writers/#handling-ir-types","title":"Handling IR Types","text":"<p>When writing a custom writer, you need to handle the various IR types. Here is a reference for the type-dispatch pattern:</p> <pre><code>from clangir.ir import (\n    Array,\n    Constant,\n    CType,\n    Enum,\n    Function,\n    FunctionPointer,\n    Header,\n    Pointer,\n    Struct,\n    Typedef,\n    Variable,\n)\n\ndef convert_type(t):\n    \"\"\"Convert a TypeExpr to your target format.\"\"\"\n    if isinstance(t, CType):\n        # Base type: t.name, t.qualifiers\n        ...\n    elif isinstance(t, Pointer):\n        # Pointer: t.pointee (recursive TypeExpr), t.qualifiers\n        inner = convert_type(t.pointee)\n        ...\n    elif isinstance(t, Array):\n        # Array: t.element_type (TypeExpr), t.size (int | str | None)\n        elem = convert_type(t.element_type)\n        ...\n    elif isinstance(t, FunctionPointer):\n        # Function pointer: t.return_type, t.parameters, t.is_variadic\n        ...\n\ndef convert_declaration(decl):\n    \"\"\"Convert a Declaration to your target format.\"\"\"\n    if isinstance(decl, Struct):\n        # decl.name, decl.fields, decl.is_union, decl.is_typedef\n        ...\n    elif isinstance(decl, Enum):\n        # decl.name, decl.values (list of EnumValue)\n        ...\n    elif isinstance(decl, Function):\n        # decl.name, decl.return_type, decl.parameters, decl.is_variadic\n        ...\n    elif isinstance(decl, Typedef):\n        # decl.name, decl.underlying_type\n        ...\n    elif isinstance(decl, Variable):\n        # decl.name, decl.type\n        ...\n    elif isinstance(decl, Constant):\n        # decl.name, decl.value, decl.is_macro\n        ...\n</code></pre>"},{"location":"guides/custom-writers/#packaging-as-a-plugin","title":"Packaging as a Plugin","text":"<p>To distribute your writer as a separate package, register it in your package's <code>__init__.py</code>:</p> <pre><code># mywriter/__init__.py\nfrom clangir.writers import register_writer\nfrom mywriter.core import MarkdownWriter\n\nregister_writer(\"markdown\", MarkdownWriter)\n</code></pre> <p>Users install your package and the writer becomes available:</p> <pre><code>pip install clangir-markdown-writer\n</code></pre> <pre><code># The import triggers registration\nimport mywriter  # noqa: F401\n\nfrom clangir import get_writer\nwriter = get_writer(\"markdown\")\n</code></pre>"},{"location":"guides/installation/","title":"Installation","text":""},{"location":"guides/installation/#install-clangir","title":"Install clangir","text":"<p>Install from PyPI:</p> <pre><code>pip install clangir\n</code></pre>"},{"location":"guides/installation/#system-dependency-libclang","title":"System Dependency: libclang","text":"<p>clangir requires the libclang shared library to be installed on your system. This is the C API for LLVM's Clang compiler, used by the built-in <code>LibclangBackend</code> to parse C and C++ headers.</p> <p>Vendored Python bindings</p> <p>clangir includes its own vendored copy of the Clang Python bindings that are automatically version-matched to your system's LLVM installation. You do not need to install <code>libclang</code> from PyPI.</p> macOSUbuntu / DebianFedora / RHELWindows <p>Install LLVM via Homebrew:</p> <pre><code>brew install llvm\n</code></pre> <p>clangir automatically searches common Homebrew paths (<code>/opt/homebrew/opt/llvm/lib/</code> on Apple Silicon, <code>/usr/local/opt/llvm/lib/</code> on Intel). Xcode Command Line Tools also include libclang.</p> <p>Install the libclang development package:</p> <pre><code>sudo apt install libclang-dev\n</code></pre> <p>For a specific LLVM version:</p> <pre><code>sudo apt install libclang-17-dev\n</code></pre> <pre><code>sudo dnf install clang-devel\n</code></pre> <p>Install LLVM from the official releases or via winget:</p> <pre><code>winget install LLVM.LLVM\n</code></pre> <p>clangir searches <code>Program Files\\LLVM\\bin\\</code> and common package manager locations (Scoop, MSYS2).</p> <p>GitHub Actions</p> <p>GitHub Actions Windows runners come with LLVM pre-installed, so no additional setup is needed in CI.</p>"},{"location":"guides/installation/#development-install","title":"Development Install","text":"<p>To contribute to clangir or run its test suite:</p> <pre><code>git clone https://github.com/axiomantic/clangir.git\ncd clangir\npip install -e '.[dev]'\n</code></pre>"},{"location":"guides/installation/#verify-installation","title":"Verify Installation","text":"<p>Confirm everything is working:</p> <pre><code>python -c \"from clangir import get_backend; b = get_backend(); print(f'Backend: {b.name}')\"\n</code></pre> <p>Expected output:</p> <pre><code>Backend: libclang\n</code></pre> <p>If you see a warning about missing backends, your libclang shared library was not found. Double-check the installation steps for your platform above.</p>"},{"location":"guides/quickstart/","title":"Quick Start","text":"<p>This guide walks through parsing a C header file with clangir and generating output in two formats: CFFI bindings and JSON.</p>"},{"location":"guides/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have installed clangir and libclang.</p>"},{"location":"guides/quickstart/#1-create-a-sample-c-header","title":"1. Create a Sample C Header","text":"<p>Save the following as <code>point.h</code>:</p> <pre><code>#include &lt;stddef.h&gt;\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\nPoint point_add(Point a, Point b);\nPoint point_scale(Point p, double factor);\ndouble point_distance(Point a, Point b);\nsize_t point_format(Point p, char *buf, size_t bufsize);\n</code></pre>"},{"location":"guides/quickstart/#2-parse-the-header","title":"2. Parse the Header","text":"<p>Use <code>get_backend()</code> to obtain a parser backend, then call its <code>parse()</code> method with the header source code:</p> <pre><code>from clangir import get_backend\n\nbackend = get_backend()\n\nwith open(\"point.h\") as f:\n    code = f.read()\n\nheader = backend.parse(code, \"point.h\")\nprint(header)\n</code></pre> <p>Output:</p> <pre><code>Header(point.h, 5 declarations)\n</code></pre>"},{"location":"guides/quickstart/#3-inspect-the-ir","title":"3. Inspect the IR","text":"<p>The <code>header.declarations</code> list contains typed IR nodes. You can inspect them directly:</p> <pre><code>from clangir import Struct, Function, Typedef\n\nfor decl in header.declarations:\n    if isinstance(decl, Struct):\n        print(f\"Struct: {decl.name}\")\n        for field in decl.fields:\n            print(f\"  {field.type} {field.name}\")\n    elif isinstance(decl, Function):\n        print(f\"Function: {decl}\")\n    elif isinstance(decl, Typedef):\n        print(f\"Typedef: {decl.name} -&gt; {decl.underlying_type}\")\n</code></pre> <p>Output:</p> <pre><code>Struct: Point\n  double x\n  double y\nFunction: Point point_add(Point a, Point b)\nFunction: Point point_scale(Point p, double factor)\nFunction: double point_distance(Point a, Point b)\nFunction: size_t point_format(Point p, char *buf, size_t bufsize)\n</code></pre>"},{"location":"guides/quickstart/#4-generate-cffi-bindings","title":"4. Generate CFFI Bindings","text":"<p>Use the built-in CFFI writer to produce <code>cdef</code>-compatible declarations:</p> <pre><code>from clangir import get_writer\n\nwriter = get_writer(\"cffi\")\ncdef_source = writer.write(header)\nprint(cdef_source)\n</code></pre> <p>Output:</p> <pre><code>typedef struct Point {\n    double x;\n    double y;\n} Point;\nPoint point_add(Point a, Point b);\nPoint point_scale(Point p, double factor);\ndouble point_distance(Point a, Point b);\nsize_t point_format(Point p, char *buf, size_t bufsize);\n</code></pre> <p>You can feed this directly to CFFI's <code>ffibuilder.cdef()</code>. See the CFFI guide for a complete example.</p>"},{"location":"guides/quickstart/#5-generate-json-output","title":"5. Generate JSON Output","text":"<p>Use the JSON writer to serialize the IR for inspection or downstream tooling:</p> <pre><code>json_writer = get_writer(\"json\", indent=2)\nprint(json_writer.write(header))\n</code></pre> <p>Output (abbreviated):</p> <pre><code>{\n  \"path\": \"point.h\",\n  \"declarations\": [\n    {\n      \"kind\": \"struct\",\n      \"name\": \"Point\",\n      \"fields\": [\n        {\"name\": \"x\", \"type\": {\"kind\": \"ctype\", \"name\": \"double\"}},\n        {\"name\": \"y\", \"type\": {\"kind\": \"ctype\", \"name\": \"double\"}}\n      ],\n      \"is_typedef\": true\n    },\n    {\n      \"kind\": \"function\",\n      \"name\": \"point_add\",\n      \"return_type\": {\"kind\": \"ctype\", \"name\": \"Point\"},\n      \"parameters\": [\n        {\"name\": \"a\", \"type\": {\"kind\": \"ctype\", \"name\": \"Point\"}},\n        {\"name\": \"b\", \"type\": {\"kind\": \"ctype\", \"name\": \"Point\"}}\n      ],\n      \"is_variadic\": false\n    }\n  ]\n}\n</code></pre> <p>See the JSON Export tutorial for advanced JSON processing techniques.</p>"},{"location":"guides/quickstart/#whats-next","title":"What's Next?","text":"<ul> <li>Architecture Overview -- understand the backend/IR/writer pipeline</li> <li>Using CFFI Writer -- complete CFFI integration with <code>ffibuilder</code></li> <li>Writing Custom Writers -- build your own output format</li> <li>API Reference -- full reference for all IR types and APIs</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>The clangir API is organized into three layers:</p> <p>IR Types -- The core data model. Dataclasses representing C/C++ declarations (structs, functions, enums, typedefs, etc.) and type expressions (pointers, arrays, function pointers). All backends produce these types; all writers consume them.</p> <p>Backends -- Parsers that read C/C++ source code and produce IR. The <code>ParserBackend</code> protocol defines the interface; the registry functions let you discover and instantiate backends.</p> <p>Writers -- Output generators that consume IR and produce target formats. The <code>WriterBackend</code> protocol defines the interface; the registry functions mirror the backend API.</p>"},{"location":"reference/#writer-implementations","title":"Writer Implementations","text":"Writer Module Description CFFI <code>clangir.writers.cffi</code> Generates <code>ffibuilder.cdef()</code> strings JSON <code>clangir.writers.json</code> Serializes IR to JSON for inspection and tooling"},{"location":"reference/#quick-example","title":"Quick Example","text":"<pre><code>from clangir.backends import get_backend\nfrom clangir.writers import get_writer\n\n# Parse a C header\nbackend = get_backend()\nheader = backend.parse(\"int add(int a, int b);\", \"math.h\")\n\n# Write CFFI output\nwriter = get_writer(\"cffi\")\nprint(writer.write(header))\n# =&gt; int add(int a, int b);\n\n# Write JSON output\njson_writer = get_writer(\"json\")\nprint(json_writer.write(header))\n</code></pre>"},{"location":"reference/backends/","title":"Backends","text":"<p>Parser backends convert C/C++ source code into the clangir IR. The <code>ParserBackend</code> protocol defines the interface that all backends implement.</p> <p>Backends are accessed through a registry. Use <code>get_backend()</code> to obtain an instance and <code>list_backends()</code> to discover what is available.</p>"},{"location":"reference/backends/#available-backends","title":"Available Backends","text":"Backend Description C++ Support Macro Extraction <code>libclang</code> LLVM clang-based parser Yes Yes"},{"location":"reference/backends/#protocol","title":"Protocol","text":"<p>See <code>ParserBackend</code> on the IR Types page for the full protocol definition including <code>parse()</code>, <code>name</code>, <code>supports_macros</code>, and <code>supports_cpp</code>.</p>"},{"location":"reference/backends/#registry-functions","title":"Registry Functions","text":""},{"location":"reference/backends/#clangir.backends.get_backend","title":"get_backend","text":"<pre><code>get_backend(name=None)\n</code></pre> <p>Get a parser backend instance.</p> <p>Returns a new instance of the requested backend. If no name is provided, returns the default backend (libclang).</p> <p>::</p> <pre><code>from clangir.backends import get_backend\n\n# Get default backend\nbackend = get_backend()\n\n# Get libclang backend\nclang = get_backend(\"libclang\")\n\n# Parse a header\nheader = backend.parse(code, \"myheader.h\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Backend name (e.g., <code>\"libclang\"</code>), or None for the default backend.</p> <code>None</code> <p>Returns:</p> Type Description <code>ParserBackend</code> <p>New instance of the requested backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested backend is not available.</p>"},{"location":"reference/backends/#clangir.backends.get_backend--example","title":"Example","text":""},{"location":"reference/backends/#clangir.backends.get_default_backend","title":"get_default_backend","text":"<pre><code>get_default_backend()\n</code></pre> <p>Get the name of the default backend.</p> <p>Returns the name of the currently configured default backend.</p> <p>::</p> <pre><code>from clangir.backends import get_default_backend\n\ndefault = get_default_backend()\nprint(f\"Default backend: {default}\")\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Backend name (e.g., \"libclang\").</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no backends are available.</p>"},{"location":"reference/backends/#clangir.backends.get_default_backend--example","title":"Example","text":""},{"location":"reference/backends/#clangir.backends.list_backends","title":"list_backends","text":"<pre><code>list_backends()\n</code></pre> <p>List names of all registered backends.</p> <p>::</p> <pre><code>from clangir.backends import list_backends\n\nfor name in list_backends():\n    print(f\"Available: {name}\")\n</code></pre> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of backend names that can be passed to :func:<code>get_backend</code>.</p>"},{"location":"reference/backends/#clangir.backends.list_backends--example","title":"Example","text":""},{"location":"reference/backends/#clangir.backends.is_backend_available","title":"is_backend_available","text":"<pre><code>is_backend_available(name)\n</code></pre> <p>Check if a backend is available for use.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Backend name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the backend is registered and can be instantiated.</p>"},{"location":"reference/backends/#clangir.backends.register_backend","title":"register_backend","text":"<pre><code>register_backend(name, backend_class, is_default=False)\n</code></pre> <p>Register a parser backend.</p> <p>Called by backend modules during import to add themselves to the registry. The first registered backend becomes the default unless <code>is_default</code> is explicitly set on a later registration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique name for the backend (e.g., <code>\"libclang\"</code>).</p> required <code>backend_class</code> <code>type[ParserBackend]</code> <p>Class implementing the :class:<code>~clangir.ir.ParserBackend</code> protocol.</p> required <code>is_default</code> <code>bool</code> <p>If True, this becomes the default backend for :func:<code>get_backend</code>.</p> <code>False</code>"},{"location":"reference/backends/#clangir.backends.get_backend_info","title":"get_backend_info","text":"<pre><code>get_backend_info()\n</code></pre> <p>Get information about all known backends.</p> <p>Returns:</p> Type Description <code>list[dict[str, str | bool]]</code> <p>List of dicts with name, available, default, and description.</p>"},{"location":"reference/cffi/","title":"CFFI Writer","text":"<p>The CFFI writer generates C declaration strings suitable for passing to <code>ffibuilder.cdef()</code>. It handles structs, unions, enums, functions, typedefs, variables, and integer constants.</p>"},{"location":"reference/cffi/#writer-class","title":"Writer Class","text":""},{"location":"reference/cffi/#clangir.writers.cffi.CffiWriter","title":"CffiWriter","text":"<pre><code>CffiWriter(exclude_patterns=None)\n</code></pre> <p>Writer that generates CFFI cdef strings from clangir IR.</p>"},{"location":"reference/cffi/#clangir.writers.cffi.CffiWriter--options","title":"Options","text":"<p>exclude_patterns : list[str] | None     Regex patterns. Declarations with names matching any pattern     are excluded from output.</p>"},{"location":"reference/cffi/#clangir.writers.cffi.CffiWriter--example","title":"Example","text":"<p>::</p> <pre><code>from clangir.writers import get_writer\n\nwriter = get_writer(\"cffi\", exclude_patterns=[\"__.*\"])\ncdef_string = writer.write(header)\n\n# Or directly:\nfrom clangir.writers.cffi import CffiWriter\nwriter = CffiWriter(exclude_patterns=[\"__.*\"])\ncdef_string = writer.write(header)\n</code></pre>"},{"location":"reference/cffi/#clangir.writers.cffi.CffiWriter.write","title":"write","text":"<pre><code>write(header)\n</code></pre> <p>Convert header IR to CFFI cdef string.</p>"},{"location":"reference/cffi/#convenience-function","title":"Convenience Function","text":""},{"location":"reference/cffi/#clangir.writers.cffi.header_to_cffi","title":"header_to_cffi","text":"<pre><code>header_to_cffi(header, exclude_patterns=None)\n</code></pre> <p>Convert all declarations in a Header to a CFFI cdef string.</p> <p>Args:     header: Parsed header IR from clangir.     exclude_patterns: List of regex patterns. Declarations with names         matching any pattern will be excluded.</p> <p>Returns:     A string suitable for passing to <code>ffibuilder.cdef()</code>.</p>"},{"location":"reference/cffi/#low-level-functions","title":"Low-Level Functions","text":"<p>These functions are used internally by <code>header_to_cffi</code> and can be useful when working with individual declarations or type expressions.</p>"},{"location":"reference/cffi/#clangir.writers.cffi.type_to_cffi","title":"type_to_cffi","text":"<pre><code>type_to_cffi(t, tag_kinds=None)\n</code></pre> <p>Convert a type expression to its CFFI string representation.</p>"},{"location":"reference/cffi/#clangir.writers.cffi.decl_to_cffi","title":"decl_to_cffi","text":"<pre><code>decl_to_cffi(decl, exclude_patterns=None, tag_kinds=None)\n</code></pre> <p>Convert a single IR declaration to a CFFI cdef string.</p> <p>Returns None if the declaration should be excluded.</p>"},{"location":"reference/ir/","title":"IR Types","text":"<p>The Intermediate Representation (IR) is the core data model of clangir. Parser backends produce IR objects; writers consume them to generate output in various formats.</p> <p>All IR types are Python dataclasses defined in the <code>clangir.ir</code> module.</p>"},{"location":"reference/ir/#container","title":"Container","text":"<p>The top-level object returned by all parser backends.</p>"},{"location":"reference/ir/#clangir.ir.Header","title":"Header  <code>dataclass</code>","text":"<pre><code>Header(path, declarations=list(), included_headers=set())\n</code></pre> <p>Container for a parsed C/C++ header file.</p> <p>This is the top-level result returned by all parser backends. It contains the file path and all extracted declarations.</p> <p>::</p> <pre><code>from clangir.backends import get_backend\nfrom clangir.ir import Struct, Function\n\nbackend = get_backend()\nheader = backend.parse(code, \"myheader.h\")\n\nprint(f\"Parsed {len(header.declarations)} declarations from {header.path}\")\n\nfor decl in header.declarations:\n    if isinstance(decl, Function):\n        print(f\"  Function: {decl.name}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the original header file.</p> required <code>declarations</code> <code>list[Declaration]</code> <p>List of extracted declarations (structs, functions, etc.).</p> <code>list()</code> <code>included_headers</code> <code>set[str]</code> <p>Set of header file basenames included by this header                          (populated by libclang backend only).</p> <code>set()</code>"},{"location":"reference/ir/#clangir.ir.Header--example","title":"Example","text":""},{"location":"reference/ir/#type-expressions","title":"Type Expressions","text":"<p>Type expressions form a recursive tree structure representing C type syntax. For example, <code>const char**</code> becomes <code>Pointer(Pointer(CType(\"char\", [\"const\"])))</code>.</p>"},{"location":"reference/ir/#clangir.ir.CType","title":"CType  <code>dataclass</code>","text":"<pre><code>CType(name, qualifiers=list())\n</code></pre> <p>A C type expression representing a base type with optional qualifiers.</p> <p>This is the fundamental building block for all type representations. Qualifiers like <code>const</code>, <code>volatile</code>, <code>unsigned</code> are stored separately from the type name for easier manipulation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The base type name (e.g., <code>\"int\"</code>, <code>\"long\"</code>, <code>\"char\"</code>).</p> required <code>qualifiers</code> <code>list[str]</code> <p>Type qualifiers (e.g., <code>[\"const\"]</code>, <code>[\"unsigned\"]</code>).</p> <code>list()</code>"},{"location":"reference/ir/#clangir.ir.CType--examples","title":"Examples","text":"<p>Simple types::</p> <pre><code>int_type = CType(\"int\")\nunsigned_long = CType(\"long\", [\"unsigned\"])\nconst_int = CType(\"int\", [\"const\"])\n</code></pre> <p>Composite types with pointers::</p> <pre><code>from clangir.ir import Pointer\n\n# const char*\nconst_char_ptr = Pointer(CType(\"char\", [\"const\"]))\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Pointer","title":"Pointer  <code>dataclass</code>","text":"<pre><code>Pointer(pointee, qualifiers=list())\n</code></pre> <p>Pointer to another type.</p> <p>Represents pointer types with optional qualifiers. Pointers can be nested to represent multi-level indirection (e.g., <code>char**</code>).</p> <p>Parameters:</p> Name Type Description Default <code>pointee</code> <code>TypeExpr</code> <p>The type being pointed to.</p> required <code>qualifiers</code> <code>list[str]</code> <p>Qualifiers on the pointer itself (e.g., <code>[\"const\"]</code>     for a const pointer, not a pointer to const).</p> <code>list()</code>"},{"location":"reference/ir/#clangir.ir.Pointer--examples","title":"Examples","text":"<p>Basic pointer::</p> <pre><code>int_ptr = Pointer(CType(\"int\"))  # int*\n</code></pre> <p>Pointer to const::</p> <pre><code>const_char_ptr = Pointer(CType(\"char\", [\"const\"]))  # const char*\n</code></pre> <p>Double pointer::</p> <pre><code>char_ptr_ptr = Pointer(Pointer(CType(\"char\")))  # char**\n</code></pre> <p>Const pointer (pointer itself is const)::</p> <pre><code>const_ptr = Pointer(CType(\"int\"), [\"const\"])  # int* const\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Array","title":"Array  <code>dataclass</code>","text":"<pre><code>Array(element_type, size=None)\n</code></pre> <p>Fixed-size or flexible array type.</p> <p>Represents C array types, which can have a fixed numeric size, a symbolic size (macro or constant), or be flexible (incomplete).</p> <p>Parameters:</p> Name Type Description Default <code>element_type</code> <code>TypeExpr</code> <p>The type of array elements.</p> required <code>size</code> <code>Union[int, str] | None</code> <p>Array size - an integer for fixed size, a string for     symbolic/expression size (e.g., <code>\"MAX_SIZE\"</code>), or None for     flexible/incomplete arrays.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.Array--examples","title":"Examples","text":"<p>Fixed-size array::</p> <pre><code>int_arr = Array(CType(\"int\"), 10)\n</code></pre> <p>Flexible array (incomplete)::</p> <pre><code>flex_arr = Array(CType(\"char\"), None)\n</code></pre> <p>Symbolic size::</p> <pre><code>buf = Array(CType(\"char\"), \"BUFFER_SIZE\")\n</code></pre> <p>Multi-dimensional array::</p> <pre><code>matrix = Array(Array(CType(\"int\"), 3), 3)\n</code></pre>"},{"location":"reference/ir/#clangir.ir.FunctionPointer","title":"FunctionPointer  <code>dataclass</code>","text":"<pre><code>FunctionPointer(return_type, parameters=list(), is_variadic=False)\n</code></pre> <p>Function pointer type.</p> <p>Represents a pointer to a function with a specific signature. Used for callbacks, vtables, and function tables.</p> <p>Parameters:</p> Name Type Description Default <code>return_type</code> <code>TypeExpr</code> <p>The function's return type.</p> required <code>parameters</code> <code>list[Parameter]</code> <p>List of function parameters.</p> <code>list()</code> <code>is_variadic</code> <code>bool</code> <p>True if the function accepts variable arguments     (ends with <code>...</code>).</p> <code>False</code>"},{"location":"reference/ir/#clangir.ir.FunctionPointer--examples","title":"Examples","text":"<p>Simple function pointer::</p> <pre><code>void_fn = FunctionPointer(CType(\"int\"), [])  # int (*)(void)\n</code></pre> <p>With parameters::</p> <pre><code>callback = FunctionPointer(\n    CType(\"void\"),\n    [Parameter(\"data\", Pointer(CType(\"void\")))]\n)  # void (*)(void* data)\n</code></pre> <p>Variadic function pointer::</p> <pre><code>printf_fn = FunctionPointer(\n    CType(\"int\"),\n    [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))],\n    is_variadic=True\n)  # int (*)(const char* fmt, ...)\n</code></pre>"},{"location":"reference/ir/#declarations","title":"Declarations","text":"<p>Declaration types represent the top-level constructs found in C/C++ headers.</p>"},{"location":"reference/ir/#clangir.ir.Enum","title":"Enum  <code>dataclass</code>","text":"<pre><code>Enum(name, values=list(), is_typedef=False, location=None)\n</code></pre> <p>Enumeration declaration.</p> <p>Represents a C enum type with named constants. Enums may be named or anonymous (used in typedefs or inline).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The enum tag name, or None for anonymous enums.</p> required <code>values</code> <code>list[EnumValue]</code> <p>List of enumeration constants.</p> <code>list()</code> <code>is_typedef</code> <code>bool</code> <p>True if this enum came from a typedef declaration.</p> <code>False</code> <code>location</code> <code>SourceLocation | None</code> <p>Source location for error reporting.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.Enum--examples","title":"Examples","text":"<p>Named enum::</p> <pre><code>color = Enum(\"Color\", [\n    EnumValue(\"RED\", 0),\n    EnumValue(\"GREEN\", 1),\n    EnumValue(\"BLUE\", 2),\n])\n</code></pre> <p>Anonymous enum (typically used with typedef)::</p> <pre><code>anon = Enum(None, [EnumValue(\"FLAG_A\", 1), EnumValue(\"FLAG_B\", 2)])\n</code></pre>"},{"location":"reference/ir/#clangir.ir.EnumValue","title":"EnumValue  <code>dataclass</code>","text":"<pre><code>EnumValue(name, value=None)\n</code></pre> <p>Single enumeration constant.</p> <p>Represents one named constant within an enum definition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The constant name.</p> required <code>value</code> <code>Union[int, str] | None</code> <p>The constant's value - an integer for explicit values,     a string for expressions (e.g., <code>\"FOO | BAR\"</code>), or None     for auto-incremented values.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.EnumValue--examples","title":"Examples","text":"<p>Explicit value::</p> <pre><code>red = EnumValue(\"RED\", 0)\n</code></pre> <p>Auto-increment (implicit value)::</p> <pre><code>green = EnumValue(\"GREEN\", None)  # follows previous value\n</code></pre> <p>Expression value::</p> <pre><code>mask = EnumValue(\"MASK\", \"FLAG_A | FLAG_B\")\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Struct","title":"Struct  <code>dataclass</code>","text":"<pre><code>Struct(name, fields=list(), methods=list(), is_union=False, is_cppclass=False, is_typedef=False, namespace=None, template_params=list(), cpp_name=None, notes=list(), inner_typedefs=dict(), location=None)\n</code></pre> <p>Struct or union declaration.</p> <p>Represents a C struct or union type definition. Both use the same IR class with <code>is_union</code> distinguishing between them.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>The struct/union tag name, or None for anonymous types.</p> required <code>fields</code> <code>list[Field]</code> <p>List of member fields.</p> <code>list()</code> <code>methods</code> <code>list[Function]</code> <p>List of methods (for C++ classes only).</p> <code>list()</code> <code>is_union</code> <code>bool</code> <p>True for unions, False for structs.</p> <code>False</code> <code>is_cppclass</code> <code>bool</code> <p>True for C++ classes (uses <code>cppclass</code> in Cython).</p> <code>False</code> <code>is_typedef</code> <code>bool</code> <p>True if this came from a typedef declaration.</p> <code>False</code> <code>location</code> <code>SourceLocation | None</code> <p>Source location for error reporting.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.Struct--examples","title":"Examples","text":"<p>Simple struct::</p> <pre><code>point = Struct(\"Point\", [\n    Field(\"x\", CType(\"int\")),\n    Field(\"y\", CType(\"int\")),\n])\n</code></pre> <p>Union::</p> <pre><code>data = Struct(\"Data\", [\n    Field(\"i\", CType(\"int\")),\n    Field(\"f\", CType(\"float\")),\n], is_union=True)\n</code></pre> <p>C++ class with method::</p> <pre><code>widget = Struct(\"Widget\", [\n    Field(\"width\", CType(\"int\")),\n], methods=[\n    Function(\"resize\", CType(\"void\"), [\n        Parameter(\"w\", CType(\"int\")),\n        Parameter(\"h\", CType(\"int\")),\n    ])\n], is_cppclass=True)\n</code></pre> <p>Anonymous struct::</p> <pre><code>anon = Struct(None, [Field(\"value\", CType(\"int\"))])\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Field","title":"Field  <code>dataclass</code>","text":"<pre><code>Field(name, type)\n</code></pre> <p>Struct or union field declaration.</p> <p>Represents a single field within a struct or union definition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The field name.</p> required <code>type</code> <code>TypeExpr</code> <p>The field's type expression.</p> required"},{"location":"reference/ir/#clangir.ir.Field--examples","title":"Examples","text":"<p>Simple field::</p> <pre><code>x_field = Field(\"x\", CType(\"int\"))  # int x\n</code></pre> <p>Pointer field::</p> <pre><code>data = Field(\"data\", Pointer(CType(\"void\")))  # void* data\n</code></pre> <p>Array field::</p> <pre><code>buffer = Field(\"buffer\", Array(CType(\"char\"), 256))  # char buffer[256]\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Function","title":"Function  <code>dataclass</code>","text":"<pre><code>Function(name, return_type, parameters=list(), is_variadic=False, namespace=None, location=None)\n</code></pre> <p>Function declaration.</p> <p>Represents a C function prototype or declaration. Does not include the function body (declarations only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The function name.</p> required <code>return_type</code> <code>TypeExpr</code> <p>The function's return type.</p> required <code>parameters</code> <code>list[Parameter]</code> <p>List of function parameters.</p> <code>list()</code> <code>is_variadic</code> <code>bool</code> <p>True if the function accepts variable arguments.</p> <code>False</code> <code>location</code> <code>SourceLocation | None</code> <p>Source location for error reporting.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.Function--examples","title":"Examples","text":"<p>Simple function::</p> <pre><code>exit_fn = Function(\"exit\", CType(\"void\"), [\n    Parameter(\"status\", CType(\"int\"))\n])\n</code></pre> <p>With return value::</p> <pre><code>strlen_fn = Function(\"strlen\", CType(\"size_t\"), [\n    Parameter(\"s\", Pointer(CType(\"char\", [\"const\"])))\n])\n</code></pre> <p>Variadic function::</p> <pre><code>printf_fn = Function(\n    \"printf\",\n    CType(\"int\"),\n    [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))],\n    is_variadic=True\n)\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Parameter","title":"Parameter  <code>dataclass</code>","text":"<pre><code>Parameter(name, type)\n</code></pre> <p>Function parameter declaration.</p> <p>Represents a single parameter in a function signature. Parameters may be named or anonymous (common in prototypes).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Parameter name, or None for anonymous parameters.</p> required <code>type</code> <code>TypeExpr</code> <p>The parameter's type expression.</p> required"},{"location":"reference/ir/#clangir.ir.Parameter--examples","title":"Examples","text":"<p>Named parameter::</p> <pre><code>x_param = Parameter(\"x\", CType(\"int\"))  # int x\n</code></pre> <p>Anonymous parameter::</p> <pre><code>anon = Parameter(None, Pointer(CType(\"void\")))  # void*\n</code></pre> <p>Complex type::</p> <pre><code>callback = Parameter(\"fn\", FunctionPointer(CType(\"void\"), []))\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Typedef","title":"Typedef  <code>dataclass</code>","text":"<pre><code>Typedef(name, underlying_type, location=None)\n</code></pre> <p>Type alias declaration.</p> <p>Represents a C typedef that creates an alias for another type. Common patterns include aliasing primitives, struct tags, and function pointer types.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new type name being defined.</p> required <code>underlying_type</code> <code>TypeExpr</code> <p>The type being aliased.</p> required <code>location</code> <code>SourceLocation | None</code> <p>Source location for error reporting.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.Typedef--examples","title":"Examples","text":"<p>Simple alias::</p> <pre><code>size_t = Typedef(\"size_t\", CType(\"long\", [\"unsigned\"]))\n</code></pre> <p>Struct typedef::</p> <pre><code>point_t = Typedef(\"Point\", CType(\"struct Point\"))\n</code></pre> <p>Function pointer typedef::</p> <pre><code>callback_t = Typedef(\"Callback\", FunctionPointer(\n    CType(\"void\"),\n    [Parameter(\"data\", Pointer(CType(\"void\")))]\n))\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Variable","title":"Variable  <code>dataclass</code>","text":"<pre><code>Variable(name, type, location=None)\n</code></pre> <p>Global variable declaration.</p> <p>Represents a global or extern variable declaration. Does not include local variables (which are not exposed in header files).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The variable name.</p> required <code>type</code> <code>TypeExpr</code> <p>The variable's type.</p> required <code>location</code> <code>SourceLocation | None</code> <p>Source location for error reporting.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.Variable--examples","title":"Examples","text":"<p>Extern variable::</p> <pre><code>errno_var = Variable(\"errno\", CType(\"int\"))\n</code></pre> <p>Const string::</p> <pre><code>version = Variable(\"version\", Pointer(CType(\"char\", [\"const\"])))\n</code></pre> <p>Array variable::</p> <pre><code>lookup_table = Variable(\"table\", Array(CType(\"int\"), 256))\n</code></pre>"},{"location":"reference/ir/#clangir.ir.Constant","title":"Constant  <code>dataclass</code>","text":"<pre><code>Constant(name, value=None, type=None, is_macro=False, location=None)\n</code></pre> <p>Compile-time constant declaration.</p> <p>Represents <code>#define</code> macros with constant values or <code>const</code> variable declarations. Only backends that support macro extraction (e.g., libclang) can populate macro constants.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The constant name.</p> required <code>value</code> <code>Union[int, float, str] | None</code> <p>The constant's value - an integer, float, or string expression. None if the value cannot be determined.</p> <code>None</code> <code>type</code> <code>CType | None</code> <p>For typed constants (<code>const int</code>), the C type. None for macros.</p> <code>None</code> <code>is_macro</code> <code>bool</code> <p>True if this is a <code>#define</code> macro, False for <code>const</code> declarations.</p> <code>False</code> <code>location</code> <code>SourceLocation | None</code> <p>Source location for error reporting.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.Constant--examples","title":"Examples","text":"<p>Numeric macro::</p> <pre><code>size = Constant(\"SIZE\", 100, is_macro=True)\n</code></pre> <p>Expression macro::</p> <pre><code>mask = Constant(\"MASK\", \"1 &lt;&lt; 4\", is_macro=True)\n</code></pre> <p>Typed const::</p> <pre><code>max_val = Constant(\"MAX_VALUE\", 255, type=CType(\"int\"))\n</code></pre> <p>String macro::</p> <pre><code>version = Constant(\"VERSION\", '\"1.0.0\"', is_macro=True)\n</code></pre>"},{"location":"reference/ir/#union-types","title":"Union Types","text":"<p>These are <code>typing.Union</code> aliases used in type annotations throughout clangir.</p>"},{"location":"reference/ir/#declaration","title":"<code>Declaration</code>","text":"<pre><code>Declaration = Union[Enum, Struct, Function, Typedef, Variable, Constant]\n</code></pre> <p>Any top-level declaration that can appear in a <code>Header</code>.</p>"},{"location":"reference/ir/#typeexpr","title":"<code>TypeExpr</code>","text":"<pre><code>TypeExpr = Union[CType, Pointer, Array, FunctionPointer]\n</code></pre> <p>Any type expression that can appear in a declaration's type fields.</p>"},{"location":"reference/ir/#source-location","title":"Source Location","text":""},{"location":"reference/ir/#clangir.ir.SourceLocation","title":"SourceLocation  <code>dataclass</code>","text":"<pre><code>SourceLocation(file, line, column=None)\n</code></pre> <p>Location in source file for error reporting and filtering.</p> <p>Used to track where declarations originated, enabling:</p> <ul> <li>Better error messages during parsing</li> <li>Filtering declarations by file (e.g., exclude system headers)</li> <li>Source mapping for debugging</li> </ul> <p>::</p> <pre><code>loc = SourceLocation(\"myheader.h\", 42, 5)\nprint(f\"Declaration at {loc.file}:{loc.line}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to the source file.</p> required <code>line</code> <code>int</code> <p>Line number (1-indexed).</p> required <code>column</code> <code>int | None</code> <p>Column number (1-indexed), or None if unknown.</p> <code>None</code>"},{"location":"reference/ir/#clangir.ir.SourceLocation--example","title":"Example","text":""},{"location":"reference/ir/#parser-backend-protocol","title":"Parser Backend Protocol","text":"<p>The parser backend protocol is defined alongside the IR types since backends produce IR directly. See also the Backends page for registry functions.</p>"},{"location":"reference/ir/#clangir.ir.ParserBackend","title":"ParserBackend","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for parser backends.</p> <p>All parser backends must implement this protocol to be usable with clangir. Backends are responsible for translating from their native AST format (pycparser, libclang, etc.) to the common :class:<code>Header</code> IR format.</p>"},{"location":"reference/ir/#clangir.ir.ParserBackend--available-backends","title":"Available Backends","text":"<ul> <li><code>libclang</code> - LLVM clang-based parser with C++ support</li> </ul>"},{"location":"reference/ir/#clangir.ir.ParserBackend--example","title":"Example","text":"<p>::</p> <pre><code>from clangir.backends import get_backend\n\n# Get default backend\nbackend = get_backend()\n\n# Get specific backend\nlibclang = get_backend(\"libclang\")\n\n# Parse code\nheader = backend.parse(\"int foo(void);\", \"test.h\")\n</code></pre>"},{"location":"reference/ir/#clangir.ir.ParserBackend.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Human-readable name of this backend (e.g., <code>\"pycparser\"</code>).</p>"},{"location":"reference/ir/#clangir.ir.ParserBackend.supports_macros","title":"supports_macros  <code>property</code>","text":"<pre><code>supports_macros\n</code></pre> <p>Whether this backend can extract <code>#define</code> constants.</p>"},{"location":"reference/ir/#clangir.ir.ParserBackend.supports_cpp","title":"supports_cpp  <code>property</code>","text":"<pre><code>supports_cpp\n</code></pre> <p>Whether this backend can parse C++ code.</p>"},{"location":"reference/ir/#clangir.ir.ParserBackend.parse","title":"parse","text":"<pre><code>parse(code, filename, include_dirs=None, extra_args=None, *, use_default_includes=True, recursive_includes=True, max_depth=10, project_prefixes=None)\n</code></pre> <p>Parse C/C++ code and return the IR representation.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Source code to parse.</p> required <code>filename</code> <code>str</code> <p>Name of the source file. Used for error messages and <code>#line</code> directives. Does not need to exist on disk.</p> required <code>include_dirs</code> <code>list[str] | None</code> <p>Directories to search for <code>#include</code> files. Only used by backends that handle preprocessing.</p> <code>None</code> <code>extra_args</code> <code>list[str] | None</code> <p>Additional arguments for the preprocessor/compiler. Format is backend-specific.</p> <code>None</code> <code>use_default_includes</code> <code>bool</code> <p>If True, add system include directories.</p> <code>True</code> <code>recursive_includes</code> <code>bool</code> <p>If True, detect umbrella headers and recursively parse included project headers.</p> <code>True</code> <code>max_depth</code> <code>int</code> <p>Maximum recursion depth for include processing.</p> <code>10</code> <code>project_prefixes</code> <code>tuple[str, ...] | None</code> <p>Path prefixes to treat as project headers.</p> <code>None</code> <p>Returns:</p> Type Description <code>Header</code> <p>Parsed header containing all extracted declarations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If parsing fails due to syntax errors.</p>"},{"location":"reference/json/","title":"JSON Writer","text":"<p>The JSON writer serializes clangir IR into JSON, useful for inspection, debugging, inter-process communication, or as input to custom code generators.</p>"},{"location":"reference/json/#writer-class","title":"Writer Class","text":""},{"location":"reference/json/#clangir.writers.json.JsonWriter","title":"JsonWriter","text":"<pre><code>JsonWriter(indent=2)\n</code></pre> <p>Writer that serializes clangir IR to JSON.</p>"},{"location":"reference/json/#clangir.writers.json.JsonWriter--options","title":"Options","text":"<p>indent : int | None     JSON indentation level. Defaults to 2. None for compact output.</p>"},{"location":"reference/json/#clangir.writers.json.JsonWriter--example","title":"Example","text":"<p>::</p> <pre><code>from clangir.writers import get_writer\n\nwriter = get_writer(\"json\", indent=4)\njson_string = writer.write(header)\n</code></pre>"},{"location":"reference/json/#clangir.writers.json.JsonWriter.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Human-readable name of this writer.</p>"},{"location":"reference/json/#clangir.writers.json.JsonWriter.format_description","title":"format_description  <code>property</code>","text":"<pre><code>format_description\n</code></pre> <p>Short description of the output format.</p>"},{"location":"reference/json/#clangir.writers.json.JsonWriter.write","title":"write","text":"<pre><code>write(header)\n</code></pre> <p>Convert header IR to JSON string.</p>"},{"location":"reference/json/#convenience-functions","title":"Convenience Functions","text":""},{"location":"reference/json/#clangir.writers.json.header_to_json","title":"header_to_json","text":"<pre><code>header_to_json(header, indent=2)\n</code></pre> <p>Convert a Header IR to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>Header</code> <p>Parsed header IR.</p> required <code>indent</code> <code>int | None</code> <p>JSON indentation level. None for compact output.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>JSON string representing the header and all declarations.</p>"},{"location":"reference/json/#clangir.writers.json.header_to_json_dict","title":"header_to_json_dict","text":"<pre><code>header_to_json_dict(header)\n</code></pre> <p>Convert a Header IR to a JSON-serializable dict (no string encoding).</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>Header</code> <p>Parsed header IR.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict representation of the header suitable for <code>json.dumps()</code>.</p>"},{"location":"reference/writers/","title":"Writers","text":"<p>Writers convert clangir IR into various output formats. The <code>WriterBackend</code> protocol defines the interface that all writers implement.</p> <p>Writers are accessed through a registry that mirrors the backend registry. Use <code>get_writer()</code> to obtain an instance and <code>list_writers()</code> to discover what is available.</p>"},{"location":"reference/writers/#available-writers","title":"Available Writers","text":"Writer Module Description <code>cffi</code> <code>clangir.writers.cffi</code> CFFI cdef declarations for <code>ffibuilder.cdef()</code> <code>json</code> <code>clangir.writers.json</code> JSON serialization for inspection and tooling"},{"location":"reference/writers/#protocol","title":"Protocol","text":""},{"location":"reference/writers/#clangir.writers.WriterBackend","title":"WriterBackend","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for output writers.</p> <p>Writers convert clangir IR (Header objects) into various output formats: CFFI cdef strings, JSON, PXD files, ctypes code, etc.</p> <p>Writer-specific options (e.g. exclude_patterns for CFFI, indent for JSON) are constructor parameters or dataclass fields on the concrete class -- NOT part of the write() signature. This keeps the protocol simple and mypy-strict compatible.</p>"},{"location":"reference/writers/#clangir.writers.WriterBackend--example","title":"Example","text":"<p>::</p> <pre><code>from clangir.writers import get_writer\n\nwriter = get_writer(\"cffi\")\noutput = writer.write(header)\n</code></pre>"},{"location":"reference/writers/#clangir.writers.WriterBackend.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre> <p>Human-readable name of this writer (e.g., <code>\"cffi\"</code>).</p>"},{"location":"reference/writers/#clangir.writers.WriterBackend.format_description","title":"format_description  <code>property</code>","text":"<pre><code>format_description\n</code></pre> <p>Short description of the output format.</p>"},{"location":"reference/writers/#clangir.writers.WriterBackend.write","title":"write","text":"<pre><code>write(header)\n</code></pre> <p>Convert parsed header IR to the target output format.</p> <p>Writers should produce best-effort output, silently skipping declarations they cannot represent. Writers must not raise exceptions for valid Header input.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>Header</code> <p>Parsed header IR from a parser backend.</p> required <p>Returns:</p> Type Description <code>str</code> <p>String representation in the target format.</p>"},{"location":"reference/writers/#registry-functions","title":"Registry Functions","text":""},{"location":"reference/writers/#clangir.writers.get_writer","title":"get_writer","text":"<pre><code>get_writer(name=None, **kwargs)\n</code></pre> <p>Get a writer instance.</p> <p>Keyword arguments are forwarded to the writer constructor, allowing per-invocation configuration::</p> <pre><code>writer = get_writer(\"cffi\", exclude_patterns=[\"__.*\"])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Writer name, or None for the default writer.</p> <code>None</code> <code>kwargs</code> <code>object</code> <p>Forwarded to writer class constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>WriterBackend</code> <p>New instance of the requested writer.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested writer is not available.</p>"},{"location":"reference/writers/#clangir.writers.get_default_writer","title":"get_default_writer","text":"<pre><code>get_default_writer()\n</code></pre> <p>Get the name of the default writer.</p> <p>Returns:</p> Type Description <code>str</code> <p>Writer name (e.g., <code>\"cffi\"</code>).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no writers are available.</p>"},{"location":"reference/writers/#clangir.writers.list_writers","title":"list_writers","text":"<pre><code>list_writers()\n</code></pre> <p>List names of all registered writers.</p> <p>::</p> <pre><code>from clangir.writers import list_writers\n\nfor name in list_writers():\n    print(f\"Available: {name}\")\n</code></pre> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of writer names that can be passed to :func:<code>get_writer</code>.</p>"},{"location":"reference/writers/#clangir.writers.list_writers--example","title":"Example","text":""},{"location":"reference/writers/#clangir.writers.is_writer_available","title":"is_writer_available","text":"<pre><code>is_writer_available(name)\n</code></pre> <p>Check if a writer is available for use.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Writer name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the writer is registered and can be instantiated.</p>"},{"location":"reference/writers/#clangir.writers.register_writer","title":"register_writer","text":"<pre><code>register_writer(name, writer_class, is_default=False, description=None)\n</code></pre> <p>Register an output writer.</p> <p>Called by writer modules during import to self-register. The first registered writer becomes the default unless <code>is_default</code> is explicitly set on a later registration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Writer name used in :func:<code>get_writer</code> lookups.</p> required <code>writer_class</code> <code>type[WriterBackend]</code> <p>The writer class implementing :class:<code>WriterBackend</code>.</p> required <code>is_default</code> <code>bool</code> <p>If True, this writer becomes the default.</p> <code>False</code> <code>description</code> <code>str | None</code> <p>Optional short description for :func:<code>get_writer_info</code>. If not provided, falls back to the class docstring's first line.</p> <code>None</code>"},{"location":"reference/writers/#clangir.writers.get_writer_info","title":"get_writer_info","text":"<pre><code>get_writer_info()\n</code></pre> <p>Get information about all known writers.</p> <p>Returns metadata from the registry without instantiating any writer. Uses descriptions stored by :func:<code>register_writer</code>, falling back to the class docstring's first line if no description was provided.</p> <p>.. note::     Keys differ from :func:<code>~clangir.backends.get_backend_info</code>:     uses <code>\"is_default\"</code> (not <code>\"default\"</code>), and omits the     <code>\"available\"</code> key (writers have no external dependencies     that could make them unavailable).</p> <p>Returns:</p> Type Description <code>list[dict[str, str | bool]]</code> <p>List of dicts with keys: name, description, is_default.</p>"},{"location":"tutorials/ctypes-writer/","title":"Tutorial: Building a ctypes Writer","text":"<p>This tutorial walks through building a clangir writer that generates Python <code>ctypes</code> binding code. The writer produces a standalone <code>.py</code> module that uses <code>ctypes</code> to load a shared library and expose its functions, structs, and enums as Python objects.</p>"},{"location":"tutorials/ctypes-writer/#what-is-ctypes","title":"What Is ctypes?","text":"<p>Python's built-in <code>ctypes</code> module provides C-compatible data types and lets you call functions in shared libraries directly from Python, without compiling any C extension code. Unlike CFFI, ctypes requires no build step.</p> <p>For example, given a C header:</p> <pre><code>int add(int a, int b);\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n</code></pre> <p>The ctypes bindings would look like:</p> <pre><code>import ctypes\n\nlib = ctypes.CDLL(\"./libmylib.so\")\n\nlib.add.argtypes = [ctypes.c_int, ctypes.c_int]\nlib.add.restype = ctypes.c_int\n\nclass Point(ctypes.Structure):\n    _fields_ = [\n        (\"x\", ctypes.c_double),\n        (\"y\", ctypes.c_double),\n    ]\n</code></pre>"},{"location":"tutorials/ctypes-writer/#step-1-type-mapping","title":"Step 1: Type Mapping","text":"<p>The core challenge is mapping C types to ctypes equivalents. Create a lookup table for primitive types:</p> <pre><code># ctypes_writer.py\n\"\"\"Generate ctypes bindings from clangir IR.\"\"\"\n\nfrom __future__ import annotations\n\nfrom clangir.ir import (\n    Array,\n    CType,\n    Enum,\n    Function,\n    FunctionPointer,\n    Header,\n    Parameter,\n    Pointer,\n    Struct,\n    Typedef,\n    TypeExpr,\n    Variable,\n)\n\n# Mapping from C type names to ctypes type names\nCTYPE_MAP = {\n    \"void\": \"None\",\n    \"char\": \"ctypes.c_char\",\n    \"signed char\": \"ctypes.c_byte\",\n    \"unsigned char\": \"ctypes.c_ubyte\",\n    \"short\": \"ctypes.c_short\",\n    \"unsigned short\": \"ctypes.c_ushort\",\n    \"int\": \"ctypes.c_int\",\n    \"unsigned int\": \"ctypes.c_uint\",\n    \"long\": \"ctypes.c_long\",\n    \"unsigned long\": \"ctypes.c_ulong\",\n    \"long long\": \"ctypes.c_longlong\",\n    \"unsigned long long\": \"ctypes.c_ulonglong\",\n    \"float\": \"ctypes.c_float\",\n    \"double\": \"ctypes.c_double\",\n    \"long double\": \"ctypes.c_longdouble\",\n    \"size_t\": \"ctypes.c_size_t\",\n    \"ssize_t\": \"ctypes.c_ssize_t\",\n    \"int8_t\": \"ctypes.c_int8\",\n    \"uint8_t\": \"ctypes.c_uint8\",\n    \"int16_t\": \"ctypes.c_int16\",\n    \"uint16_t\": \"ctypes.c_uint16\",\n    \"int32_t\": \"ctypes.c_int32\",\n    \"uint32_t\": \"ctypes.c_uint32\",\n    \"int64_t\": \"ctypes.c_int64\",\n    \"uint64_t\": \"ctypes.c_uint64\",\n    \"_Bool\": \"ctypes.c_bool\",\n    \"bool\": \"ctypes.c_bool\",\n}\n</code></pre>"},{"location":"tutorials/ctypes-writer/#step-2-type-conversion-function","title":"Step 2: Type Conversion Function","text":"<p>Build a recursive type converter that handles pointers, arrays, and function pointers:</p> <pre><code>def type_to_ctypes(t: TypeExpr) -&gt; str:\n    \"\"\"Convert an IR type expression to a ctypes type string.\"\"\"\n    if isinstance(t, CType):\n        # Check for const char* (handled at pointer level)\n        # Build the full type name including qualifiers like \"unsigned\"\n        full_name = t.name\n        type_qualifiers = []\n        for q in t.qualifiers:\n            if q in (\"unsigned\", \"signed\", \"long\", \"short\"):\n                full_name = f\"{q} {full_name}\"\n            else:\n                type_qualifiers.append(q)\n\n        return CTYPE_MAP.get(full_name, full_name)\n\n    elif isinstance(t, Pointer):\n        # Special case: char* -&gt; c_char_p, const char* -&gt; c_char_p\n        if isinstance(t.pointee, CType) and t.pointee.name == \"char\":\n            return \"ctypes.c_char_p\"\n        # void* -&gt; c_void_p\n        if isinstance(t.pointee, CType) and t.pointee.name == \"void\":\n            return \"ctypes.c_void_p\"\n        # Function pointer\n        if isinstance(t.pointee, FunctionPointer):\n            return _funcptr_to_ctypes(t.pointee)\n        # General pointer\n        inner = type_to_ctypes(t.pointee)\n        return f\"ctypes.POINTER({inner})\"\n\n    elif isinstance(t, Array):\n        elem = type_to_ctypes(t.element_type)\n        if t.size is not None and isinstance(t.size, int):\n            return f\"({elem} * {t.size})\"\n        return f\"ctypes.POINTER({elem})\"\n\n    elif isinstance(t, FunctionPointer):\n        return _funcptr_to_ctypes(t)\n\n    return f\"ctypes.c_void_p  # unknown: {t}\"\n\n\ndef _funcptr_to_ctypes(fp: FunctionPointer) -&gt; str:\n    \"\"\"Convert a function pointer to a ctypes CFUNCTYPE expression.\"\"\"\n    restype = type_to_ctypes(fp.return_type)\n    argtypes = [type_to_ctypes(p.type) for p in fp.parameters]\n    all_types = [restype] + argtypes\n    return f\"ctypes.CFUNCTYPE({', '.join(all_types)})\"\n</code></pre>"},{"location":"tutorials/ctypes-writer/#step-3-declaration-handlers","title":"Step 3: Declaration Handlers","text":"<p>Write functions to generate ctypes code for each declaration type:</p> <pre><code>def _struct_to_ctypes(decl: Struct) -&gt; list[str]:\n    \"\"\"Generate a ctypes Structure or Union subclass.\"\"\"\n    if decl.name is None:\n        return []\n\n    base = \"ctypes.Union\" if decl.is_union else \"ctypes.Structure\"\n\n    lines = [\n        f\"class {decl.name}({base}):\",\n    ]\n\n    if not decl.fields:\n        lines.append(\"    pass\")\n        return lines\n\n    lines.append(\"    _fields_ = [\")\n    for field in decl.fields:\n        ctype = type_to_ctypes(field.type)\n        lines.append(f'        (\"{field.name}\", {ctype}),')\n    lines.append(\"    ]\")\n\n    return lines\n\n\ndef _enum_to_ctypes(decl: Enum) -&gt; list[str]:\n    \"\"\"Generate enum constants as module-level integers.\"\"\"\n    if not decl.values:\n        return []\n\n    lines = []\n    if decl.name:\n        lines.append(f\"# enum {decl.name}\")\n    auto_value = 0\n    for v in decl.values:\n        if v.value is not None and isinstance(v.value, int):\n            lines.append(f\"{v.name} = {v.value}\")\n            auto_value = v.value + 1\n        else:\n            lines.append(f\"{v.name} = {auto_value}\")\n            auto_value += 1\n\n    return lines\n\n\ndef _function_to_ctypes(decl: Function) -&gt; list[str]:\n    \"\"\"Generate ctypes function binding setup code.\"\"\"\n    lines = []\n    # argtypes\n    argtypes = [type_to_ctypes(p.type) for p in decl.parameters]\n    lines.append(f\"lib.{decl.name}.argtypes = [{', '.join(argtypes)}]\")\n    # restype\n    restype = type_to_ctypes(decl.return_type)\n    lines.append(f\"lib.{decl.name}.restype = {restype}\")\n\n    return lines\n\n\ndef _typedef_to_ctypes(decl: Typedef) -&gt; list[str]:\n    \"\"\"Generate a type alias.\"\"\"\n    ctype = type_to_ctypes(decl.underlying_type)\n    return [f\"{decl.name} = {ctype}\"]\n</code></pre>"},{"location":"tutorials/ctypes-writer/#step-4-the-writer-class","title":"Step 4: The Writer Class","text":"<p>Assemble everything into a writer:</p> <pre><code>from clangir.writers import register_writer\n\n\nclass CtypesWriter:\n    \"\"\"Writer that generates Python ctypes binding code.\"\"\"\n\n    def __init__(self, library_name: str = \"mylib\") -&gt; None:\n        self._library_name = library_name\n\n    def write(self, header: Header) -&gt; str:\n        lines = [\n            '\"\"\"Auto-generated ctypes bindings.\"\"\"',\n            \"\",\n            \"import ctypes\",\n            \"import os\",\n            \"\",\n            f'lib = ctypes.CDLL(os.path.join(os.path.dirname(__file__), \"lib{self._library_name}.so\"))',\n            \"\",\n        ]\n\n        # Emit structs and unions first (functions may reference them)\n        for decl in header.declarations:\n            if isinstance(decl, Struct):\n                struct_lines = _struct_to_ctypes(decl)\n                if struct_lines:\n                    lines.extend(struct_lines)\n                    lines.append(\"\")\n\n        # Emit enums\n        for decl in header.declarations:\n            if isinstance(decl, Enum):\n                enum_lines = _enum_to_ctypes(decl)\n                if enum_lines:\n                    lines.extend(enum_lines)\n                    lines.append(\"\")\n\n        # Emit typedefs\n        for decl in header.declarations:\n            if isinstance(decl, Typedef):\n                td_lines = _typedef_to_ctypes(decl)\n                if td_lines:\n                    lines.extend(td_lines)\n                    lines.append(\"\")\n\n        # Emit function bindings\n        for decl in header.declarations:\n            if isinstance(decl, Function):\n                fn_lines = _function_to_ctypes(decl)\n                if fn_lines:\n                    lines.extend(fn_lines)\n                    lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    @property\n    def name(self) -&gt; str:\n        return \"ctypes\"\n\n    @property\n    def format_description(self) -&gt; str:\n        return \"Python ctypes binding code\"\n\n\n# Register the writer\nregister_writer(\"ctypes\", CtypesWriter, description=\"Python ctypes binding code\")\n</code></pre>"},{"location":"tutorials/ctypes-writer/#step-5-try-it-out","title":"Step 5: Try It Out","text":"<pre><code>from clangir import get_backend, get_writer\nimport ctypes_writer  # noqa: F401  -- triggers registration\n\ncode = \"\"\"\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ntypedef enum {\n    SHAPE_CIRCLE = 0,\n    SHAPE_RECT = 1,\n    SHAPE_TRIANGLE = 2,\n} ShapeType;\n\nPoint point_add(Point a, Point b);\ndouble point_distance(Point a, Point b);\nvoid point_print(Point p, const char *label);\n\"\"\"\n\nbackend = get_backend()\nheader = backend.parse(code, \"point.h\")\n\nwriter = get_writer(\"ctypes\", library_name=\"point\")\nprint(writer.write(header))\n</code></pre> <p>Expected output:</p> <pre><code>\"\"\"Auto-generated ctypes bindings.\"\"\"\n\nimport ctypes\nimport os\n\nlib = ctypes.CDLL(os.path.join(os.path.dirname(__file__), \"libpoint.so\"))\n\nclass Point(ctypes.Structure):\n    _fields_ = [\n        (\"x\", ctypes.c_double),\n        (\"y\", ctypes.c_double),\n    ]\n\n# enum ShapeType\nSHAPE_CIRCLE = 0\nSHAPE_RECT = 1\nSHAPE_TRIANGLE = 2\n\nlib.point_add.argtypes = [Point, Point]\nlib.point_add.restype = Point\n\nlib.point_distance.argtypes = [Point, Point]\nlib.point_distance.restype = ctypes.c_double\n\nlib.point_print.argtypes = [Point, ctypes.c_char_p]\nlib.point_print.restype = None\n</code></pre>"},{"location":"tutorials/ctypes-writer/#improvements-for-production","title":"Improvements for Production","text":"<p>A production-quality ctypes writer would benefit from:</p> <ul> <li>Platform-aware library loading -- use <code>.dylib</code> on macOS, <code>.dll</code> on Windows</li> <li>Struct forward references -- when struct A has a pointer to struct B that is declared later</li> <li>Opaque pointers -- emit <code>c_void_p</code> for structs with no fields</li> <li>Callback typedefs -- generate <code>CFUNCTYPE</code> wrappers for function pointer typedefs</li> <li>Error checking -- add <code>errcheck</code> hooks for functions that return error codes</li> </ul>"},{"location":"tutorials/ctypes-writer/#whats-next","title":"What's Next","text":"<ul> <li>PXD Writer Tutorial -- building a Cython writer</li> <li>Writing Custom Writers -- the general writer development guide</li> <li>JSON Export Tutorial -- using the built-in JSON writer</li> </ul>"},{"location":"tutorials/header-cleanup/","title":"Tutorial: Building a C Header Cleanup Writer","text":"<p>This tutorial builds a clangir writer that takes a parsed header and emits a clean, simplified C header. The writer strips preprocessor artifacts, normalizes typedefs, and filters declarations to produce a minimal public API header.</p>"},{"location":"tutorials/header-cleanup/#why-clean-up-headers","title":"Why Clean Up Headers?","text":"<p>Real-world C headers accumulate complexity over time:</p> <ul> <li>Preprocessor conditionals (<code>#ifdef</code>, <code>#ifndef</code>) leave behind confusing structure</li> <li>System includes pull in platform-specific types and macros</li> <li>Internal implementation details get mixed with public API</li> <li>Inconsistent formatting makes headers hard to read</li> </ul> <p>By parsing a header into clangir's IR and writing it back as clean C, you get a normalized, minimal version that contains only the declarations you care about.</p>"},{"location":"tutorials/header-cleanup/#step-1-type-conversion","title":"Step 1: Type Conversion","text":"<p>First, write a function to convert IR type expressions back into C syntax:</p> <pre><code># header_cleanup_writer.py\n\"\"\"Generate clean, minimal C headers from clangir IR.\"\"\"\n\nfrom __future__ import annotations\n\nfrom clangir.ir import (\n    Array,\n    Constant,\n    CType,\n    Enum,\n    Function,\n    FunctionPointer,\n    Header,\n    Parameter,\n    Pointer,\n    Struct,\n    Typedef,\n    TypeExpr,\n    Variable,\n)\n\n\ndef type_to_c(t: TypeExpr) -&gt; str:\n    \"\"\"Convert an IR type expression to a C type string.\"\"\"\n    if isinstance(t, CType):\n        if t.qualifiers:\n            return f\"{' '.join(t.qualifiers)} {t.name}\"\n        return t.name\n\n    elif isinstance(t, Pointer):\n        if isinstance(t.pointee, FunctionPointer):\n            # Function pointer -- handled specially by callers\n            return _funcptr_to_c(t.pointee, name=None)\n        inner = type_to_c(t.pointee)\n        quals = f\" {' '.join(t.qualifiers)}\" if t.qualifiers else \"\"\n        return f\"{inner} *{quals}\"\n\n    elif isinstance(t, Array):\n        size_str = str(t.size) if t.size is not None else \"\"\n        return f\"{type_to_c(t.element_type)}[{size_str}]\"\n\n    elif isinstance(t, FunctionPointer):\n        return _funcptr_to_c(t, name=None)\n\n    return str(t)\n\n\ndef _funcptr_to_c(fp: FunctionPointer, name: str | None) -&gt; str:\n    \"\"\"Convert a function pointer to C syntax.\"\"\"\n    ret = type_to_c(fp.return_type)\n    params = _format_params(fp.parameters, fp.is_variadic)\n    name_str = name or \"\"\n    return f\"{ret} (*{name_str})({params})\"\n\n\ndef _format_params(parameters: list[Parameter], is_variadic: bool) -&gt; str:\n    \"\"\"Format a parameter list as a C string.\"\"\"\n    if not parameters and not is_variadic:\n        return \"void\"\n    parts = []\n    for p in parameters:\n        type_str = type_to_c(p.type)\n        if p.name:\n            if isinstance(p.type, Array):\n                size_str = str(p.type.size) if p.type.size is not None else \"\"\n                parts.append(f\"{type_to_c(p.type.element_type)} {p.name}[{size_str}]\")\n            elif isinstance(p.type, FunctionPointer):\n                parts.append(_funcptr_to_c(p.type, name=p.name))\n            else:\n                parts.append(f\"{type_str} {p.name}\")\n        else:\n            parts.append(type_str)\n    if is_variadic:\n        parts.append(\"...\")\n    return \", \".join(parts)\n</code></pre>"},{"location":"tutorials/header-cleanup/#step-2-declaration-handlers","title":"Step 2: Declaration Handlers","text":"<p>Write handlers for each declaration type, producing clean C syntax:</p> <pre><code>def _emit_struct(decl: Struct) -&gt; list[str]:\n    \"\"\"Emit a struct or union declaration.\"\"\"\n    if decl.name is None:\n        return []\n\n    kind = \"union\" if decl.is_union else \"struct\"\n\n    if not decl.fields:\n        # Opaque type -- forward declaration\n        if decl.is_typedef:\n            return [f\"typedef {kind} {decl.name} {decl.name};\"]\n        return [f\"{kind} {decl.name};\"]\n\n    lines = []\n    if decl.is_typedef:\n        lines.append(f\"typedef {kind} {decl.name} {{\")\n    else:\n        lines.append(f\"{kind} {decl.name} {{\")\n\n    for field in decl.fields:\n        if isinstance(field.type, Array):\n            size_str = str(field.type.size) if field.type.size is not None else \"\"\n            lines.append(f\"    {type_to_c(field.type.element_type)} {field.name}[{size_str}];\")\n        elif isinstance(field.type, FunctionPointer):\n            lines.append(f\"    {_funcptr_to_c(field.type, name=field.name)};\")\n        else:\n            lines.append(f\"    {type_to_c(field.type)} {field.name};\")\n\n    if decl.is_typedef:\n        lines.append(f\"}} {decl.name};\")\n    else:\n        lines.append(\"};\")\n\n    return lines\n\n\ndef _emit_enum(decl: Enum) -&gt; list[str]:\n    \"\"\"Emit an enum declaration.\"\"\"\n    if not decl.values:\n        return []\n\n    lines = []\n    if decl.is_typedef and decl.name:\n        lines.append(f\"typedef enum {{\")\n    elif decl.name:\n        lines.append(f\"enum {decl.name} {{\")\n    else:\n        lines.append(\"enum {\")\n\n    for v in decl.values:\n        if v.value is not None:\n            lines.append(f\"    {v.name} = {v.value},\")\n        else:\n            lines.append(f\"    {v.name},\")\n\n    if decl.is_typedef and decl.name:\n        lines.append(f\"}} {decl.name};\")\n    else:\n        lines.append(\"};\")\n\n    return lines\n\n\ndef _emit_function(decl: Function) -&gt; list[str]:\n    \"\"\"Emit a function prototype.\"\"\"\n    params = _format_params(decl.parameters, decl.is_variadic)\n    return [f\"{type_to_c(decl.return_type)} {decl.name}({params});\"]\n\n\ndef _emit_typedef(decl: Typedef) -&gt; list[str]:\n    \"\"\"Emit a typedef.\"\"\"\n    underlying = decl.underlying_type\n\n    if isinstance(underlying, Pointer) and isinstance(underlying.pointee, FunctionPointer):\n        fp = underlying.pointee\n        params = _format_params(fp.parameters, fp.is_variadic)\n        return [f\"typedef {type_to_c(fp.return_type)} (*{decl.name})({params});\"]\n\n    if isinstance(underlying, FunctionPointer):\n        params = _format_params(underlying.parameters, underlying.is_variadic)\n        return [f\"typedef {type_to_c(underlying.return_type)} (*{decl.name})({params});\"]\n\n    if isinstance(underlying, Array):\n        size_str = str(underlying.size) if underlying.size is not None else \"\"\n        return [f\"typedef {type_to_c(underlying.element_type)} {decl.name}[{size_str}];\"]\n\n    return [f\"typedef {type_to_c(underlying)} {decl.name};\"]\n\n\ndef _emit_variable(decl: Variable) -&gt; list[str]:\n    \"\"\"Emit an extern variable declaration.\"\"\"\n    return [f\"extern {type_to_c(decl.type)} {decl.name};\"]\n\n\ndef _emit_constant(decl: Constant) -&gt; list[str]:\n    \"\"\"Emit a constant definition.\"\"\"\n    if decl.is_macro and decl.value is not None:\n        return [f\"#define {decl.name} {decl.value}\"]\n    elif decl.type is not None and decl.value is not None:\n        return [f\"const {type_to_c(decl.type)} {decl.name} = {decl.value};\"]\n    return []\n</code></pre>"},{"location":"tutorials/header-cleanup/#step-3-filtering-and-the-writer-class","title":"Step 3: Filtering and the Writer Class","text":"<p>The real value of a cleanup writer is filtering. Add options to control which declarations make it into the output:</p> <pre><code>import re\nfrom clangir.writers import register_writer\n\n\nclass HeaderCleanupWriter:\n    \"\"\"Writer that produces clean, minimal C headers.\n\n    Options:\n        include_patterns: Only include declarations matching these patterns.\n        exclude_patterns: Exclude declarations matching these patterns.\n        strip_prefixes: Remove these prefixes from declaration names.\n        add_header_guard: Wrap output in #ifndef/#define/#endif.\n    \"\"\"\n\n    def __init__(\n        self,\n        include_patterns: list[str] | None = None,\n        exclude_patterns: list[str] | None = None,\n        strip_prefixes: list[str] | None = None,\n        add_header_guard: bool = True,\n    ) -&gt; None:\n        self._include = [re.compile(p) for p in (include_patterns or [])]\n        self._exclude = [re.compile(p) for p in (exclude_patterns or [])]\n        self._strip_prefixes = strip_prefixes or []\n        self._add_guard = add_header_guard\n\n    def _should_include(self, name: str | None) -&gt; bool:\n        \"\"\"Check if a declaration should be included in output.\"\"\"\n        if name is None:\n            return False\n        # Exclude patterns take priority\n        for pat in self._exclude:\n            if pat.search(name):\n                return False\n        # If include patterns are specified, name must match at least one\n        if self._include:\n            return any(pat.search(name) for pat in self._include)\n        return True\n\n    def write(self, header: Header) -&gt; str:\n        lines: list[str] = []\n\n        # Header guard\n        guard_name = \"\"\n        if self._add_guard:\n            guard_name = re.sub(r\"[^A-Z0-9]\", \"_\", header.path.upper()) + \"_H\"\n            lines.append(f\"#ifndef {guard_name}\")\n            lines.append(f\"#define {guard_name}\")\n            lines.append(\"\")\n\n        # Emit filtered declarations\n        for decl in header.declarations:\n            name = getattr(decl, \"name\", None)\n            if not self._should_include(name):\n                continue\n\n            decl_lines = self._emit(decl)\n            if decl_lines:\n                lines.extend(decl_lines)\n                lines.append(\"\")\n\n        # Close header guard\n        if self._add_guard:\n            lines.append(f\"#endif /* {guard_name} */\")\n            lines.append(\"\")\n\n        return \"\\n\".join(lines)\n\n    def _emit(self, decl) -&gt; list[str]:\n        if isinstance(decl, Struct):\n            return _emit_struct(decl)\n        elif isinstance(decl, Enum):\n            return _emit_enum(decl)\n        elif isinstance(decl, Function):\n            return _emit_function(decl)\n        elif isinstance(decl, Typedef):\n            return _emit_typedef(decl)\n        elif isinstance(decl, Variable):\n            return _emit_variable(decl)\n        elif isinstance(decl, Constant):\n            return _emit_constant(decl)\n        return []\n\n    @property\n    def name(self) -&gt; str:\n        return \"header-cleanup\"\n\n    @property\n    def format_description(self) -&gt; str:\n        return \"Clean, minimal C header files\"\n\n\nregister_writer(\n    \"header-cleanup\",\n    HeaderCleanupWriter,\n    description=\"Clean, minimal C header files\",\n)\n</code></pre>"},{"location":"tutorials/header-cleanup/#step-4-try-it-out","title":"Step 4: Try It Out","text":"<pre><code>from clangir import get_backend, get_writer\nimport header_cleanup_writer  # noqa: F401\n\ncode = \"\"\"\n#define _INTERNAL_FLAG 1\n#define API_VERSION 3\n\ntypedef struct {\n    int _private_field;\n    double x;\n    double y;\n} Point;\n\ntypedef struct {\n    void *_impl;\n} _InternalHandle;\n\nPoint point_create(double x, double y);\nvoid _internal_init(void);\ndouble point_distance(Point a, Point b);\n\"\"\"\n\nbackend = get_backend()\nheader = backend.parse(code, \"point.h\")\n\nwriter = get_writer(\n    \"header-cleanup\",\n    exclude_patterns=[\"^_\"],  # Exclude names starting with underscore\n    add_header_guard=True,\n)\nprint(writer.write(header))\n</code></pre> <p>Expected output:</p> <pre><code>#ifndef POINT_H_H\n#define POINT_H_H\n\n#define API_VERSION 3\n\ntypedef struct Point {\n    int _private_field;\n    double x;\n    double y;\n} Point;\n\nPoint point_create(double x, double y);\n\ndouble point_distance(Point a, Point b);\n\n#endif /* POINT_H_H */\n</code></pre> <p>Notice that <code>_InternalHandle</code>, <code>_internal_init</code>, and <code>_INTERNAL_FLAG</code> were all filtered out because their names start with an underscore.</p>"},{"location":"tutorials/header-cleanup/#use-case-public-api-extraction","title":"Use Case: Public API Extraction","text":"<p>For libraries with large internal headers, use <code>include_patterns</code> to extract only the public API:</p> <pre><code>writer = get_writer(\n    \"header-cleanup\",\n    include_patterns=[\"^mylib_\"],  # Only keep functions/types with mylib_ prefix\n    exclude_patterns=[\"_internal\", \"_private\"],\n)\n</code></pre>"},{"location":"tutorials/header-cleanup/#use-case-api-surface-documentation","title":"Use Case: API Surface Documentation","text":"<p>Combine with the JSON writer to create a CI pipeline that tracks your library's public API:</p> <pre><code>from clangir import get_backend, get_writer\n\nbackend = get_backend()\n\nwith open(\"mylib.h\") as f:\n    header = backend.parse(f.read(), \"mylib.h\")\n\n# Write clean header for documentation\ncleanup = get_writer(\"header-cleanup\", exclude_patterns=[\"^_\"])\nwith open(\"docs/api.h\", \"w\") as f:\n    f.write(cleanup.write(header))\n\n# Write JSON for machine processing\njson_writer = get_writer(\"json\", indent=2)\nwith open(\"docs/api.json\", \"w\") as f:\n    f.write(json_writer.write(header))\n</code></pre>"},{"location":"tutorials/header-cleanup/#whats-next","title":"What's Next","text":"<ul> <li>Writing Custom Writers -- general guide for writer development</li> <li>JSON Export Tutorial -- serialize IR for tooling and CI/CD</li> <li>PXD Writer Tutorial -- building a Cython declaration writer</li> </ul>"},{"location":"tutorials/json-export/","title":"Tutorial: JSON Export and IR Inspection","text":"<p>The built-in JSON writer serializes clangir's IR into a structured JSON document. This is useful for inspecting parsed headers, building custom tooling, diffing API surfaces in CI/CD, and feeding header metadata into other programs.</p>"},{"location":"tutorials/json-export/#basic-usage","title":"Basic Usage","text":""},{"location":"tutorials/json-export/#using-get_writer","title":"Using get_writer()","text":"<pre><code>from clangir import get_backend, get_writer\n\nbackend = get_backend()\nheader = backend.parse(open(\"mylib.h\").read(), \"mylib.h\")\n\nwriter = get_writer(\"json\", indent=2)\nprint(writer.write(header))\n</code></pre>"},{"location":"tutorials/json-export/#using-header_to_json-directly","title":"Using header_to_json() Directly","text":"<p>The <code>header_to_json()</code> function provides the same functionality:</p> <pre><code>from clangir import get_backend\nfrom clangir.writers.json import header_to_json\n\nbackend = get_backend()\nheader = backend.parse(open(\"mylib.h\").read(), \"mylib.h\")\n\njson_str = header_to_json(header, indent=2)\nprint(json_str)\n</code></pre> <p>For programmatic use, <code>header_to_json_dict()</code> returns a Python dict instead of a string:</p> <pre><code>from clangir.writers.json import header_to_json_dict\n\ndata = header_to_json_dict(header)\nfor decl in data[\"declarations\"]:\n    print(f\"{decl['kind']}: {decl.get('name', '(anonymous)')}\")\n</code></pre>"},{"location":"tutorials/json-export/#json-schema-overview","title":"JSON Schema Overview","text":"<p>The JSON output follows a consistent structure. Every node includes a <code>\"kind\"</code> field that identifies its type.</p>"},{"location":"tutorials/json-export/#top-level-structure","title":"Top-Level Structure","text":"<pre><code>{\n  \"path\": \"mylib.h\",\n  \"declarations\": [ ... ],\n  \"included_headers\": [\"stdio.h\", \"stdlib.h\"]\n}\n</code></pre> <p>The <code>included_headers</code> field is only present when the header includes other files and the backend tracks them.</p>"},{"location":"tutorials/json-export/#type-expression-kinds","title":"Type Expression Kinds","text":"<p>Type expressions use the <code>\"kind\"</code> discriminator:</p> Kind Fields C Equivalent <code>\"ctype\"</code> <code>name</code>, <code>qualifiers</code> (optional) <code>int</code>, <code>const char</code> <code>\"pointer\"</code> <code>pointee</code> (nested type) , <code>qualifiers</code> (optional) <code>int*</code>, <code>void**</code> <code>\"array\"</code> <code>element_type</code>, <code>size</code> (optional) <code>int[10]</code>, <code>char[]</code> <code>\"function_pointer\"</code> <code>return_type</code>, <code>parameters</code>, <code>is_variadic</code> <code>void (*)(int)</code> <p>Example -- <code>const char*</code>:</p> <pre><code>{\n  \"kind\": \"pointer\",\n  \"pointee\": {\n    \"kind\": \"ctype\",\n    \"name\": \"char\",\n    \"qualifiers\": [\"const\"]\n  }\n}\n</code></pre>"},{"location":"tutorials/json-export/#declaration-kinds","title":"Declaration Kinds","text":"Kind Key Fields <code>\"struct\"</code> <code>name</code>, <code>fields</code>, <code>is_typedef</code>, <code>is_union</code> (when union) <code>\"enum\"</code> <code>name</code>, <code>values</code> (list of <code>{name, value}</code>), <code>is_typedef</code> <code>\"function\"</code> <code>name</code>, <code>return_type</code>, <code>parameters</code>, <code>is_variadic</code> <code>\"typedef\"</code> <code>name</code>, <code>underlying_type</code> <code>\"variable\"</code> <code>name</code>, <code>type</code> <code>\"constant\"</code> <code>name</code>, <code>value</code>, <code>is_macro</code> (optional) <p>Structs and unions share the same schema. Unions have <code>\"kind\": \"union\"</code> while structs have <code>\"kind\": \"struct\"</code>.</p>"},{"location":"tutorials/json-export/#worked-example","title":"Worked Example","text":"<p>Given this C header:</p> <pre><code>// calculator.h\ntypedef enum {\n    OP_ADD = 0,\n    OP_SUB = 1,\n    OP_MUL = 2,\n    OP_DIV = 3,\n} Operation;\n\ntypedef struct {\n    double result;\n    int error;\n} CalcResult;\n\nCalcResult calculate(double a, double b, Operation op);\n</code></pre> <p>The JSON output is:</p> <pre><code>{\n  \"path\": \"calculator.h\",\n  \"declarations\": [\n    {\n      \"kind\": \"enum\",\n      \"name\": \"Operation\",\n      \"values\": [\n        {\"name\": \"OP_ADD\", \"value\": 0},\n        {\"name\": \"OP_SUB\", \"value\": 1},\n        {\"name\": \"OP_MUL\", \"value\": 2},\n        {\"name\": \"OP_DIV\", \"value\": 3}\n      ],\n      \"is_typedef\": true\n    },\n    {\n      \"kind\": \"struct\",\n      \"name\": \"CalcResult\",\n      \"fields\": [\n        {\"name\": \"result\", \"type\": {\"kind\": \"ctype\", \"name\": \"double\"}},\n        {\"name\": \"error\", \"type\": {\"kind\": \"ctype\", \"name\": \"int\"}}\n      ],\n      \"is_typedef\": true\n    },\n    {\n      \"kind\": \"function\",\n      \"name\": \"calculate\",\n      \"return_type\": {\"kind\": \"ctype\", \"name\": \"CalcResult\"},\n      \"parameters\": [\n        {\"name\": \"a\", \"type\": {\"kind\": \"ctype\", \"name\": \"double\"}},\n        {\"name\": \"b\", \"type\": {\"kind\": \"ctype\", \"name\": \"double\"}},\n        {\"name\": \"op\", \"type\": {\"kind\": \"ctype\", \"name\": \"Operation\"}}\n      ],\n      \"is_variadic\": false\n    }\n  ]\n}\n</code></pre>"},{"location":"tutorials/json-export/#processing-json-with-python","title":"Processing JSON with Python","text":""},{"location":"tutorials/json-export/#list-all-functions","title":"List All Functions","text":"<pre><code>import json\nfrom clangir import get_backend\nfrom clangir.writers.json import header_to_json_dict\n\nbackend = get_backend()\nheader = backend.parse(open(\"mylib.h\").read(), \"mylib.h\")\ndata = header_to_json_dict(header)\n\nfunctions = [d for d in data[\"declarations\"] if d[\"kind\"] == \"function\"]\nfor fn in functions:\n    params = \", \".join(\n        f\"{p['type']['name']} {p.get('name', '')}\"\n        for p in fn[\"parameters\"]\n        if p[\"type\"][\"kind\"] == \"ctype\"\n    )\n    print(f\"{fn['name']}({params})\")\n</code></pre>"},{"location":"tutorials/json-export/#find-structs-with-pointer-fields","title":"Find Structs with Pointer Fields","text":"<pre><code>for decl in data[\"declarations\"]:\n    if decl[\"kind\"] == \"struct\" and decl.get(\"fields\"):\n        pointer_fields = [\n            f for f in decl[\"fields\"]\n            if f[\"type\"][\"kind\"] == \"pointer\"\n        ]\n        if pointer_fields:\n            names = \", \".join(f[\"name\"] for f in pointer_fields)\n            print(f\"{decl['name']} has pointer fields: {names}\")\n</code></pre>"},{"location":"tutorials/json-export/#processing-json-with-jq","title":"Processing JSON with jq","text":"<p>The JSON output is well-suited for processing with jq:</p>"},{"location":"tutorials/json-export/#list-all-declaration-names","title":"List All Declaration Names","text":"<pre><code>python -c \"\nfrom clangir import get_backend\nfrom clangir.writers.json import header_to_json\nbackend = get_backend()\nheader = backend.parse(open('mylib.h').read(), 'mylib.h')\nprint(header_to_json(header))\n\" | jq '.declarations[].name'\n</code></pre>"},{"location":"tutorials/json-export/#extract-function-signatures","title":"Extract Function Signatures","text":"<pre><code>cat output.json | jq '.declarations[] | select(.kind == \"function\") | {name, params: [.parameters[].name]}'\n</code></pre>"},{"location":"tutorials/json-export/#count-declarations-by-kind","title":"Count Declarations by Kind","text":"<pre><code>cat output.json | jq '[.declarations[].kind] | group_by(.) | map({kind: .[0], count: length})'\n</code></pre>"},{"location":"tutorials/json-export/#use-case-cicd-api-diffing","title":"Use Case: CI/CD API Diffing","text":"<p>Use JSON export to detect API changes between releases:</p> <pre><code>\"\"\"Compare two header versions and report API changes.\"\"\"\n\nimport json\nfrom clangir import get_backend\nfrom clangir.writers.json import header_to_json_dict\n\n\ndef get_api_surface(header_path: str) -&gt; dict[str, str]:\n    \"\"\"Extract function names and their kinds from a header.\"\"\"\n    backend = get_backend()\n    with open(header_path) as f:\n        header = backend.parse(f.read(), header_path)\n    data = header_to_json_dict(header)\n\n    return {\n        decl[\"name\"]: decl[\"kind\"]\n        for decl in data[\"declarations\"]\n        if decl.get(\"name\")\n    }\n\n\ndef diff_apis(old_path: str, new_path: str) -&gt; None:\n    old_api = get_api_surface(old_path)\n    new_api = get_api_surface(new_path)\n\n    added = set(new_api) - set(old_api)\n    removed = set(old_api) - set(new_api)\n\n    if added:\n        print(\"Added:\")\n        for name in sorted(added):\n            print(f\"  + {new_api[name]} {name}\")\n\n    if removed:\n        print(\"Removed:\")\n        for name in sorted(removed):\n            print(f\"  - {old_api[name]} {name}\")\n\n    if not added and not removed:\n        print(\"No API changes detected.\")\n</code></pre>"},{"location":"tutorials/json-export/#compact-output","title":"Compact Output","text":"<p>For machine-to-machine communication, use <code>indent=None</code> for compact JSON:</p> <pre><code>writer = get_writer(\"json\", indent=None)\ncompact = writer.write(header)\n# Single line, no whitespace\n</code></pre> <p>Or with the function:</p> <pre><code>from clangir.writers.json import header_to_json\n\ncompact = header_to_json(header, indent=None)\n</code></pre>"},{"location":"tutorials/json-export/#whats-next","title":"What's Next","text":"<ul> <li>Using CFFI Writer -- generate CFFI bindings from the same IR</li> <li>Writing Custom Writers -- build your own output format</li> <li>API Reference: JSON Writer -- full API details</li> </ul>"},{"location":"tutorials/pxd-writer/","title":"Tutorial: Building a PXD Writer (Cython)","text":"<p>This tutorial walks through building a clangir writer that generates Cython <code>.pxd</code> declaration files from parsed C headers. By the end, you will have a working writer that handles functions, structs, enums, and typedefs.</p>"},{"location":"tutorials/pxd-writer/#what-are-pxd-files","title":"What Are .pxd Files?","text":"<p>Cython uses <code>.pxd</code> files to declare C interfaces. They are similar to C header files but use Cython syntax, allowing Python code to call C functions directly. A <code>.pxd</code> file tells Cython about the types and function signatures available in a C library.</p> <p>For example, given this C header:</p> <pre><code>typedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble point_distance(Point a, Point b);\n</code></pre> <p>The corresponding <code>.pxd</code> file would be:</p> <pre><code>cdef extern from \"point.h\":\n    ctypedef struct Point:\n        double x\n        double y\n\n    double point_distance(Point a, Point b)\n</code></pre>"},{"location":"tutorials/pxd-writer/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>Create a file for the writer:</p> <pre><code># pxd_writer.py\n\"\"\"Generate Cython .pxd declarations from clangir IR.\"\"\"\n\nfrom __future__ import annotations\n\nfrom clangir.ir import (\n    Array,\n    CType,\n    Enum,\n    Function,\n    FunctionPointer,\n    Header,\n    Parameter,\n    Pointer,\n    Struct,\n    Typedef,\n    TypeExpr,\n    Variable,\n)\n</code></pre>"},{"location":"tutorials/pxd-writer/#step-2-type-conversion","title":"Step 2: Type Conversion","text":"<p>The first building block is converting IR type expressions to Cython type strings. Cython type syntax is nearly identical to C, so this is straightforward:</p> <pre><code>def type_to_pxd(t: TypeExpr) -&gt; str:\n    \"\"\"Convert an IR type expression to Cython syntax.\"\"\"\n    if isinstance(t, CType):\n        if t.qualifiers:\n            return f\"{' '.join(t.qualifiers)} {t.name}\"\n        return t.name\n\n    elif isinstance(t, Pointer):\n        if isinstance(t.pointee, FunctionPointer):\n            # Function pointer: rendered inline\n            return _function_pointer_to_pxd(t.pointee)\n        return f\"{type_to_pxd(t.pointee)}*\"\n\n    elif isinstance(t, Array):\n        size_str = str(t.size) if t.size is not None else \"\"\n        return f\"{type_to_pxd(t.element_type)}[{size_str}]\"\n\n    elif isinstance(t, FunctionPointer):\n        return _function_pointer_to_pxd(t)\n\n    return str(t)\n\n\ndef _function_pointer_to_pxd(fp: FunctionPointer) -&gt; str:\n    \"\"\"Convert a function pointer to Cython syntax.\"\"\"\n    params = \", \".join(_param_to_pxd(p) for p in fp.parameters)\n    if fp.is_variadic:\n        params = f\"{params}, ...\" if params else \"...\"\n    if not params:\n        params = \"void\"\n    return f\"{type_to_pxd(fp.return_type)} (*)({params})\"\n\n\ndef _param_to_pxd(p: Parameter) -&gt; str:\n    \"\"\"Convert a parameter to Cython syntax.\"\"\"\n    type_str = type_to_pxd(p.type)\n    if p.name:\n        return f\"{type_str} {p.name}\"\n    return type_str\n</code></pre>"},{"location":"tutorials/pxd-writer/#step-3-declaration-handlers","title":"Step 3: Declaration Handlers","text":"<p>Now write handlers for each declaration type. In <code>.pxd</code> files, everything lives inside a <code>cdef extern from</code> block and is indented:</p> <pre><code>def _struct_to_pxd(decl: Struct, indent: str = \"    \") -&gt; list[str]:\n    \"\"\"Convert a struct/union to Cython .pxd lines.\"\"\"\n    if decl.name is None:\n        return []\n\n    keyword = \"union\" if decl.is_union else \"struct\"\n    prefix = \"ctypedef \" if decl.is_typedef else \"\"\n\n    if not decl.fields:\n        # Opaque struct -- forward declaration\n        return [f\"{indent}{prefix}{keyword} {decl.name}\"]\n\n    lines = [f\"{indent}{prefix}{keyword} {decl.name}:\"]\n    for field in decl.fields:\n        if isinstance(field.type, Array):\n            size_str = str(field.type.size) if field.type.size is not None else \"\"\n            lines.append(\n                f\"{indent}    {type_to_pxd(field.type.element_type)} {field.name}[{size_str}]\"\n            )\n        elif isinstance(field.type, FunctionPointer):\n            fp = field.type\n            fp_params = \", \".join(_param_to_pxd(p) for p in fp.parameters)\n            if fp.is_variadic:\n                fp_params = f\"{fp_params}, ...\" if fp_params else \"...\"\n            lines.append(\n                f\"{indent}    {type_to_pxd(fp.return_type)} (*{field.name})({fp_params})\"\n            )\n        else:\n            lines.append(f\"{indent}    {type_to_pxd(field.type)} {field.name}\")\n\n    return lines\n\n\ndef _enum_to_pxd(decl: Enum, indent: str = \"    \") -&gt; list[str]:\n    \"\"\"Convert an enum to Cython .pxd lines.\"\"\"\n    if not decl.values:\n        return []\n\n    prefix = \"ctypedef \" if decl.is_typedef else \"\"\n    name = decl.name or \"\"\n\n    lines = [f\"{indent}{prefix}enum {name}:\"]\n    for v in decl.values:\n        lines.append(f\"{indent}    {v.name}\")\n\n    return lines\n\n\ndef _function_to_pxd(decl: Function, indent: str = \"    \") -&gt; list[str]:\n    \"\"\"Convert a function to Cython .pxd lines.\"\"\"\n    params = \", \".join(_param_to_pxd(p) for p in decl.parameters)\n    if decl.is_variadic:\n        params = f\"{params}, ...\" if params else \"...\"\n    if not params:\n        params = \"void\"\n\n    return [f\"{indent}{type_to_pxd(decl.return_type)} {decl.name}({params})\"]\n\n\ndef _typedef_to_pxd(decl: Typedef, indent: str = \"    \") -&gt; list[str]:\n    \"\"\"Convert a typedef to Cython .pxd lines.\"\"\"\n    underlying = decl.underlying_type\n\n    # Function pointer typedef\n    if isinstance(underlying, Pointer) and isinstance(\n        underlying.pointee, FunctionPointer\n    ):\n        fp = underlying.pointee\n        fp_params = \", \".join(_param_to_pxd(p) for p in fp.parameters)\n        if fp.is_variadic:\n            fp_params = f\"{fp_params}, ...\" if fp_params else \"...\"\n        return [\n            f\"{indent}ctypedef {type_to_pxd(fp.return_type)} (*{decl.name})({fp_params})\"\n        ]\n\n    return [f\"{indent}ctypedef {type_to_pxd(underlying)} {decl.name}\"]\n\n\ndef _variable_to_pxd(decl: Variable, indent: str = \"    \") -&gt; list[str]:\n    \"\"\"Convert a variable to Cython .pxd lines.\"\"\"\n    return [f\"{indent}{type_to_pxd(decl.type)} {decl.name}\"]\n</code></pre>"},{"location":"tutorials/pxd-writer/#step-4-the-writer-class","title":"Step 4: The Writer Class","text":"<p>Assemble the declaration handlers into a full writer class:</p> <pre><code>from clangir.writers import register_writer\n\n\nclass PxdWriter:\n    \"\"\"Writer that generates Cython .pxd declaration files.\"\"\"\n\n    def __init__(self, header_name: str | None = None) -&gt; None:\n        self._header_name = header_name\n\n    def write(self, header: Header) -&gt; str:\n        \"\"\"Convert header IR to Cython .pxd format.\"\"\"\n        # Use provided header name or fall back to the header's path\n        extern_name = self._header_name or header.path\n\n        lines: list[str] = []\n        lines.append(f'cdef extern from \"{extern_name}\":')\n\n        for decl in header.declarations:\n            decl_lines = self._convert_declaration(decl)\n            if decl_lines:\n                lines.append(\"\")  # Blank line between declarations\n                lines.extend(decl_lines)\n\n        lines.append(\"\")  # Trailing newline\n        return \"\\n\".join(lines)\n\n    def _convert_declaration(self, decl) -&gt; list[str]:\n        if isinstance(decl, Struct):\n            return _struct_to_pxd(decl)\n        elif isinstance(decl, Enum):\n            return _enum_to_pxd(decl)\n        elif isinstance(decl, Function):\n            return _function_to_pxd(decl)\n        elif isinstance(decl, Typedef):\n            return _typedef_to_pxd(decl)\n        elif isinstance(decl, Variable):\n            return _variable_to_pxd(decl)\n        return []\n\n    @property\n    def name(self) -&gt; str:\n        return \"pxd\"\n\n    @property\n    def format_description(self) -&gt; str:\n        return \"Cython .pxd declaration files\"\n\n\n# Register the writer\nregister_writer(\"pxd\", PxdWriter, description=\"Cython .pxd declaration files\")\n</code></pre>"},{"location":"tutorials/pxd-writer/#step-5-try-it-out","title":"Step 5: Try It Out","text":"<p>Test the writer with a sample header:</p> <pre><code>from clangir import get_backend, get_writer\n\n# Make sure pxd_writer is imported so it registers itself\nimport pxd_writer  # noqa: F401\n\ncode = \"\"\"\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ntypedef enum {\n    COLOR_RED,\n    COLOR_GREEN,\n    COLOR_BLUE,\n} Color;\n\nPoint point_add(Point a, Point b);\ndouble point_distance(Point a, Point b);\nvoid point_print(Point p, const char *fmt, ...);\n\"\"\"\n\nbackend = get_backend()\nheader = backend.parse(code, \"point.h\")\n\nwriter = get_writer(\"pxd\")\nprint(writer.write(header))\n</code></pre> <p>Expected output:</p> <pre><code>cdef extern from \"point.h\":\n\n    ctypedef struct Point:\n        double x\n        double y\n\n    ctypedef enum Color:\n        COLOR_RED\n        COLOR_GREEN\n        COLOR_BLUE\n\n    Point point_add(Point a, Point b)\n\n    double point_distance(Point a, Point b)\n\n    void point_print(Point p, const char *fmt, ...)\n</code></pre>"},{"location":"tutorials/pxd-writer/#step-6-edge-cases-to-consider","title":"Step 6: Edge Cases to Consider","text":"<p>A production-quality <code>.pxd</code> writer would also need to handle:</p> <ul> <li>Nested struct pointers -- when one struct contains a pointer to another struct</li> <li>Opaque types -- structs with no fields should emit a forward declaration only</li> <li>Anonymous enums -- skip the name or use a generated name</li> <li>C++ classes -- use <code>cppclass</code> instead of <code>struct</code> when <code>decl.is_cppclass</code> is <code>True</code></li> <li>Namespaces -- wrap declarations in <code>namespace</code> blocks when <code>decl.namespace</code> is set</li> <li>Array fields -- emit <code>type name[size]</code> syntax inside structs</li> <li>Const qualifiers -- preserve <code>const</code> on pointer targets</li> </ul>"},{"location":"tutorials/pxd-writer/#whats-next","title":"What's Next","text":"<ul> <li>Writing Custom Writers -- the general guide for writer development</li> <li>ctypes Writer Tutorial -- another writer tutorial with a different target format</li> <li>Architecture Overview -- understand the full backend/IR/writer pipeline</li> </ul>"}]}